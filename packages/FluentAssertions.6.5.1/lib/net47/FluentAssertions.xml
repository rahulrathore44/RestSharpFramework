<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluentAssertions</name>
    </assembly>
    <members>
        <member name="M:FluentAssertions.AndConstraint`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.AndConstraint`1"/> class.
            </summary>
        </member>
        <member name="T:FluentAssertions.AndWhichConstraint`2">
            <summary>
            Constraint which can be returned from an assertion which matches a condition and which will allow
            further matches to be performed on the matched condition as well as the parent constraint.
            </summary>
            <typeparam name="TParentConstraint">The type of the original constraint that was matched</typeparam>
            <typeparam name="TMatchedElement">The type of the matched object which the parent constraint matched</typeparam>
        </member>
        <member name="P:FluentAssertions.AndWhichConstraint`2.Which">
            <summary>
            Returns the single result of a prior assertion that is used to select a nested or collection item.
            </summary>
        </member>
        <member name="P:FluentAssertions.AndWhichConstraint`2.Subject">
            <summary>
            Returns the single result of a prior assertion that is used to select a nested or collection item.
            </summary>
            <remarks>
            Just a convenience property that returns the same value as <see cref="P:FluentAssertions.AndWhichConstraint`2.Which"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.AssertionExtensions">
            <summary>
            Contains extension methods for custom assertions in unit tests.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Invoking``1(``0,System.Action{``0})">
            <summary>
            Invokes the specified action on a subject so that you can chain it
            with any of the assertions from <see cref="T:FluentAssertions.Specialized.ActionAssertions"/>
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Invoking``2(``0,System.Func{``0,``1})">
            <summary>
            Invokes the specified action on a subject so that you can chain it
            with any of the assertions from <see cref="T:FluentAssertions.Specialized.FunctionAssertions`1"/>
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Awaiting``1(``0,System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Invokes the specified action on a subject so that you can chain it
            with any of the assertions from <see cref="T:FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions"/>
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Awaiting``2(``0,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Invokes the specified action on a subject so that you can chain it
            with any of the assertions from <see cref="T:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1"/>
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Awaiting``1(``0,System.Func{``0,System.Threading.Tasks.ValueTask})">
            <summary>
            Invokes the specified action on a subject so that you can chain it
            with any of the assertions from <see cref="T:FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions"/>
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Awaiting``2(``0,System.Func{``0,System.Threading.Tasks.ValueTask{``1}})">
            <summary>
            Invokes the specified action on a subject so that you can chain it
            with any of the assertions from <see cref="T:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1"/>
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ExecutionTimeOf``1(``0,System.Linq.Expressions.Expression{System.Action{``0}},FluentAssertions.Common.StartTimer)">
            <summary>
            Provides methods for asserting the execution time of a method or property.
            </summary>
            <param name="subject">The object that exposes the method or property.</param>
            <param name="action">A reference to the method or property to measure the execution time of.</param>
            <returns>
            Returns an object for asserting that the execution time matches certain conditions.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ExecutionTime(System.Action,FluentAssertions.Common.StartTimer)">
            <summary>
            Provides methods for asserting the execution time of an action.
            </summary>
            <param name="action">An action to measure the execution time of.</param>
            <returns>
            Returns an object for asserting that the execution time matches certain conditions.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ExecutionTime(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Provides methods for asserting the execution time of an async action.
            </summary>
            <param name="action">An async action to measure the execution time of.</param>
            <returns>
            Returns an object for asserting that the execution time matches certain conditions.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTime)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Specialized.ExecutionTimeAssertions"/> object that can be used to assert the
            current <see cref="T:FluentAssertions.Specialized.ExecutionTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.Assembly)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Reflection.AssemblyAssertions"/> object that can be used to assert the
            current <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Xml.Linq.XDocument)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Xml.XDocumentAssertions"/> object that can be used to assert the
            current <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Xml.Linq.XElement)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Xml.XElementAssertions"/> object that can be used to assert the
            current <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Xml.Linq.XAttribute)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Xml.XAttributeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Xml.Linq.XAttribute"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.IO.Stream)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Streams.StreamAssertions"/> object that can be used to assert the
            current <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.IO.BufferedStream)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Streams.BufferedStreamAssertions"/> object that can be used to assert the
            current <see cref="T:System.IO.BufferedStream"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Enumerating(System.Func{System.Collections.IEnumerable})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Enumerating``1(System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Enumerating``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Forces enumerating a collection of the provided <paramref name="subject"/>.
            Should be used to assert that a method that uses the <c>yield</c> keyword throws a particular exception.
            </summary>
            <param name="subject">The object that exposes the method or property.</param>
            <param name="enumerable">A reference to the method or property to force enumeration of.</param>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Object)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.ObjectAssertions"/> object that can be used to assert the
            current <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Boolean)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.BooleanAssertions"/> object that can be used to assert the
            current <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Boolean})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableBooleanAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Net.Http.HttpResponseMessage)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.HttpResponseMessageAssertions"/> object that can be used to assert the
            current <see cref="T:System.Net.Http.HttpResponseMessage"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Guid)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.GuidAssertions"/> object that can be used to assert the
            current <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Guid})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableGuidAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericCollectionAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.StringCollectionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericDictionaryAssertions`3"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericDictionaryAssertions`3"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``3(``0)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericDictionaryAssertions`3"/> object that can be used to assert the
            current <typeparamref name="TCollection"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Data.DataColumn)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Data.DataColumnAssertions"/> object that can be used to assert the
            current <see cref="T:System.Data.DataColumn"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.DateTime)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.DateTimeAssertions"/> object that can be used to assert the
            current <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.DateTimeOffset)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.DateTimeOffsetAssertions"/> object that can be used to assert the
            current <see cref="T:System.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.DateTime})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableDateTimeAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.DateTimeOffset})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.IComparable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.ComparableTypeAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.IComparable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Int32)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Int32})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.UInt32)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.UInt32})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Decimal)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Decimal})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Byte)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Byte})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.SByte)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.SByte})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Int16)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Int16})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.UInt16)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.UInt16})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Int64)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Int64})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.UInt64)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.UInt64})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Single)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Single})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Double)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Double})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.String)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.StringAssertions"/> object that can be used to assert the
            current <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.TimeSpan)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions"/> object that can be used to assert the
            current <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.TimeSpan})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Type)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="typeSelector"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.ConstructorInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodBaseAssertions`2"/> object
            that can be used to assert the current <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.MethodInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodInfoAssertions"/> object that can be used to assert the current <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.MethodInfoSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodInfoSelectorAssertions"/> object that can be used to assert the methods returned by the
            current <see cref="T:FluentAssertions.Types.MethodInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="methodSelector"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.PropertyInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.PropertyInfoAssertions"/> object that can be used to assert the
            current <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.PropertyInfoSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.PropertyInfoSelectorAssertions"/> object that can be used to assert the properties returned by the
            current <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfoSelector"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Action)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.ActionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Action"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Func`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1"/> object that can be used to assert the
            current <see><cref>System.Func{Task{T}}</cref></see>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.Func{``0})">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.FunctionAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Func`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.TaskCompletionSourceAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Monitor``1(``0,System.Func{System.DateTime})">
            <summary>
            Starts monitoring <paramref name="eventSource"/> for its events.
            </summary>
            <param name="eventSource">The object for which to monitor the events.</param>
            <param name="utcNow">
            An optional delegate that returns the current date and time in UTC format.
            Will revert to <see cref="P:System.DateTime.UtcNow"/> if no delegate was provided.
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="eventSource"/> is Null.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.As``1(System.Object)">
            <summary>
            Safely casts the specified object to the type specified through <typeparamref name="TTo"/>.
            </summary>
            <remarks>
            Has been introduced to allow casting objects without breaking the fluent API.
            </remarks>
            <typeparam name="TTo">The <see cref="T:System.Type"/> to cast <paramref name="subject"/> to</typeparam>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``2(FluentAssertions.Primitives.ReferenceTypeAssertions{``0,``1})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(FluentAssertions.Primitives.BooleanAssertions{``0})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(FluentAssertions.Primitives.DateTimeAssertions{``0})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(FluentAssertions.Primitives.DateTimeOffsetAssertions{``0})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)">
            <summary>
            You are asserting the <see cref="T:FluentAssertions.AndConstraint`1"/> itself. Remove the <c>Should()</c> method directly following <c>And</c>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(FluentAssertions.Primitives.GuidAssertions{``0})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.MethodInfoSelectorAssertions)">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``2(FluentAssertions.Numeric.NumericAssertions{``0,``1})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.PropertyInfoSelectorAssertions)">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(FluentAssertions.Primitives.SimpleTimeSpanAssertions{``0})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(FluentAssertions.Specialized.TaskCompletionSourceAssertions{``0})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.TypeSelectorAssertions)">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``2(FluentAssertions.Primitives.EnumAssertions{``0,``1})">
            <inheritdoc cref="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTimeAssertions)" />
        </member>
        <member name="T:FluentAssertions.AssertionOptions">
            <summary>
            Holds any global options that control the behavior of FluentAssertions.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionOptions.AssertEquivalencyUsing(System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions,FluentAssertions.Equivalency.EquivalencyAssertionOptions})">
            <summary>
            Allows configuring the defaults used during a structural equivalency assertion.
            </summary>
            <param name="defaultsConfigurer">
            An action that is used to configure the defaults.
            </param>
        </member>
        <member name="P:FluentAssertions.AssertionOptions.EquivalencyPlan">
            <summary>
            Represents a mutable plan consisting of steps that are executed while asserting a (collection of) object(s)
            is structurally equivalent to another (collection of) object(s).
            </summary>
        </member>
        <member name="P:FluentAssertions.AssertionOptions.FormattingOptions">
            <summary>
            Gets the default formatting options used by the formatters in Fluent Assertions.
            </summary>
        </member>
        <member name="M:FluentAssertions.AsyncAssertionsExtensions.WithResult``1(System.Threading.Tasks.Task{FluentAssertions.AndWhichConstraint{FluentAssertions.Specialized.GenericAsyncFunctionAssertions{``0},``0}},``0,System.String,System.Object[])">
            <summary>
            Asserts that the completed <see cref="T:System.Threading.Tasks.Task`1"/> provides the specified result.
            </summary>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1"/> containing the <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.AsyncAssertionsExtensions.WithResult``1(System.Threading.Tasks.Task{FluentAssertions.AndWhichConstraint{FluentAssertions.Specialized.TaskCompletionSourceAssertions{``0},``0}},``0,System.String,System.Object[])">
            <summary>
            Asserts that the completed <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> provides the specified result.
            </summary>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.TaskCompletionSourceAssertions`1"/> containing the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.</param>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="F:FluentAssertions.CallerIdentification.AddNonEmptySymbolParsingStrategy.Mode.RemoveAllWhitespace">
            <summary>
            Remove all whitespace until we find a non-whitespace character
            </summary>
        </member>
        <member name="F:FluentAssertions.CallerIdentification.AddNonEmptySymbolParsingStrategy.Mode.RemoveSuperfluousWhitespace">
            <summary>
            Only keep one whitespace character if more than one follow each other.
            </summary>
        </member>
        <member name="T:FluentAssertions.CallerIdentification.IParsingStrategy">
             <summary>
             Represents a stateful parsing strategy that is used to help identify the "caller" to use in an assertion message.
            
             The strategies will be instantiated at the beginning of a "caller identification" task, and will live until
             the statement can be identified (and thus some are stateful).
             </summary>
        </member>
        <member name="M:FluentAssertions.CallerIdentification.IParsingStrategy.Parse(System.Char,System.Text.StringBuilder)">
            <summary>
            Given a symbol, the parsing strategy should add/remove from the statement if needed, and then return
            - InProgress if the symbol isn't relevant to the strategies (so other strategies can be tried)
            - Handled if an action has been taken (and no other strategies should be used for this symbol)
            - Done if the statement is complete, and thus further symbols should be read.
            </summary>
        </member>
        <member name="M:FluentAssertions.CallerIdentification.IParsingStrategy.IsWaitingForContextEnd">
            <summary>
            Returns true if strategy is in the middle of a context (ex: strategy read "/*" and is waiting for "*/"
            </summary>
        </member>
        <member name="M:FluentAssertions.CallerIdentification.IParsingStrategy.NotifyEndOfLineReached">
            <summary>
            Used to notify the strategy that we have reached the end of the line (very useful to detect the end of
            a single line comment).
            </summary>
        </member>
        <member name="T:FluentAssertions.CallerIdentifier">
            <summary>
            Tries to extract the name of the variable or invocation on which the assertion is executed.
            </summary>
        </member>
        <member name="P:FluentAssertions.Collections.GenericCollectionAssertions`3.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllBeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the specified type <typeparamref name="TExpectation" />
            </summary>
            <typeparam name="TExpectation">The expected type of the objects</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllBeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the specified type <paramref name="expectedType"/>
            </summary>
            <param name="expectedType">The expected type of the objects</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectedType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllBeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that all elements in a collection of objects are equivalent to a given object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to given object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllBeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that all elements in a collection of objects are equivalent to a given object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to given object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllBeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the exact specified type <typeparamref name="TExpectation" />
            </summary>
            <typeparam name="TExpectation">The expected type of the objects</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllBeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the exact specified type <paramref name="expectedType"/>
            </summary>
            <param name="expectedType">The expected type of the objects</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectedType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInAscendingOrder(System.Collections.Generic.IComparer{`1},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the specified
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInAscendingOrder(System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInAscendingOrder(System.Func{`1,`1,System.Int32},System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in ascending order. Elements are compared
            using the given lambda expression.
            </summary>
            <param name="comparison">
            A lambda expression that should be used to determine the expected ordering between two objects.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInDescendingOrder(System.Collections.Generic.IComparer{`1},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the specified
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInDescendingOrder(System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInDescendingOrder(System.Func{`1,`1,System.Int32},System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in descending order. Elements are compared
            using the given lambda expression.
            </summary>
            <param name="comparison">
            A lambda expression that should be used to determine the expected ordering between two objects.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection is null or does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeSubsetOf(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the collection is a subset of the <paramref name="expectedSuperset" />.
            </summary>
            <param name="expectedSuperset">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected superset.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectedSuperset"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Contain(`1,System.String,System.Object[])">
            <summary>
            Asserts that the collection contains the specified item.
            </summary>
            <param name="expected">The expectation item.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Contain(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least one item that matches the predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Contain(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="expected"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainEquivalentOf``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects contains at least one object equivalent to another object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to the expected object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainEquivalentOf``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects contains at least one object equivalent to another object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to the expected object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="config"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainInOrder(`1[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order, not necessarily consecutive.
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainInOrder(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order, not necessarily consecutive.
            </summary>
            <remarks>
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </remarks>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainItemsAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the current collection contains at least one element that is assignable to the type <typeparamref name="TExpectation" />.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainSingle(System.String,System.Object[])">
            <summary>
            Expects the current collection to contain only a single item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.ContainSingle(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain only a single item matching the specified <paramref name="predicate"/>.
            </summary>
            <param name="predicate">The predicate that will be used to find the matching items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.EndWith(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the current collection ends with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.EndWith``1(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the current collection ends with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using <paramref name="equalityComparison"/>.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="equalityComparison">
            A equality comparison the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.EndWith(`1,System.String,System.Object[])">
            <summary>
            Asserts that the collection ends with the specified <paramref name="element"/>.
            </summary>
            <param name="element">
            The element that is expected to appear at the end of the collection. The object's <see cref="M:System.Object.Equals(System.Object)"/>
            is used to compare the element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Equal(`1[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="elements" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> method.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that two collections contain the same items in the same order, where equality is determined using a
            <paramref name="equalityComparison"/>.
            </summary>
            <param name="expectation">
            The collection to compare the subject with.
            </param>
            <param name="equalityComparison">
            A equality comparison the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Equal(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="expected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The expected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches a condition stated by the <paramref name="countPredicate"/>.
            </summary>
            <param name="countPredicate">A predicate that yields the number of items that is expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="countPredicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveCountGreaterThanOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is greater than or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveCountGreaterThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is greater than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveCountLessThanOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is less than or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveCountLessThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is less than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveElementAt(System.Int32,`1,System.String,System.Object[])">
            <summary>
            Asserts that the current collection has the supplied <paramref name="element" /> at the
            supplied <paramref name="index" />.
            </summary>
            <param name="index">The index where the element is expected</param>
            <param name="element">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveElementPreceding(`1,`1,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="expectation"/> element directly precedes the <paramref name="successor"/>.
            </summary>
            <param name="successor">The element that should succeed <paramref name="expectation"/>.</param>
            <param name="expectation">The expected element that should precede <paramref name="successor"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveElementSucceeding(`1,`1,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="expectation"/> element directly succeeds the <paramref name="predecessor"/>.
            </summary>
            <param name="predecessor">The element that should precede <paramref name="expectation"/>.</param>
            <param name="expectation">The element that should succeed <paramref name="predecessor"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.HaveSameCount``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object[])">
            <summary>
            Assert that the current collection has the same number of elements as <paramref name="otherCollection" />.
            </summary>
            <param name="otherCollection">The other collection with the same expected number of elements</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherCollection"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.IntersectWith(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the collection shares one or more items with the specified <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected shared items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherCollection"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all elements of the collection identified by <paramref name="unexpected" />,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all elements of the collection identified by <paramref name="unexpected" />,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the unexpected elements.</param>
            /// <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInAscendingOrder(System.Collections.Generic.IComparer{`1},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in ascending order according to the value of the specified
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInAscendingOrder(System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInAscendingOrder(System.Func{`1,`1,System.Int32},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in ascending order according to the provided lambda expression.
            </summary>
            <param name="comparison">
            A lambda expression that should be used to determine the expected ordering between two objects.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInDescendingOrder(System.Collections.Generic.IComparer{`1},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in descending order according to the value of the specified
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection not is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInDescendingOrder(System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInDescendingOrder(System.Func{`1,`1,System.Int32},System.String,System.Object[])">
            <summary>
            Asserts that a collection is not ordered in descending order according to the provided lambda expression.
            </summary>
            <param name="comparison">
            A lambda expression that should be used to determine the expected ordering between two objects.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection is not null and contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeSubsetOf(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the collection is not a subset of the <paramref name="unexpectedSuperset" />.
            </summary>
            <param name="unexpectedSuperset">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the unexpected superset.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContain(`1,System.String,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied <paramref name="unexpected" /> item.
            </summary>
            <param name="unexpected">The element that is not expected to be in the collection</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContain(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any items that match the predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContain(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied items. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unexpected"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="unexpected"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContainEquivalentOf``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects does not contain any object equivalent to another object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to the expected object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="unexpected">The unexpected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContainEquivalentOf``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects does not contain any object equivalent to another object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to the expected object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="unexpected">The unexpected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="config"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContainInOrder(`1[])">
            <summary>
            Asserts the current collection does not contain the specified elements in the exact same order, not necessarily consecutive.
            </summary>
            <remarks>
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </remarks>
            <param name="unexpected">A <see cref="T:System.Array"/> with the unexpected elements.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unexpected"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContainInOrder(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts the current collection does not contain the specified elements in the exact same order, not necessarily consecutive.
            </summary>
            <remarks>
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </remarks>
            <param name="unexpected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unexpected"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContainNulls``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any <c>null</c> items.
            </summary>
            <param name="predicate">The predicate when evaluated should not be null.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotContainNulls(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any <c>null</c> items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotEqual(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all the same elements in the same order as the collection identified by
            <paramref name="unexpected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the elements that are not expected.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unexpected"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotHaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection does not match the supplied <paramref name="unexpected" /> amount.
            </summary>
            <param name="unexpected">The unexpected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotHaveSameCount``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object[])">
            <summary>
            Assert that the current collection does not have the same number of elements as <paramref name="otherCollection" />.
            </summary>
            <param name="otherCollection">The other collection with the unexpected number of elements</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherCollection"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotIntersectWith(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not share any items with the specified <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherCollection"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.OnlyContain(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection only contains items that match a predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.OnlyHaveUniqueItems``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any duplicate items.
            </summary>
            <param name="predicate">The predicate to group the items by.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.OnlyHaveUniqueItems(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any duplicate items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.AllSatisfy(System.Action{`1},System.String,System.Object[])">
            <summary>
            Asserts that a collection contains only items which meet
            the criteria provided by the inspector.
            </summary>
            <param name="expected">
            The element inspector, which inspects each element in turn.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.SatisfyRespectively(System.Action{`1}[])">
            <summary>
            Asserts that a collection contains exactly a given number of elements, which meet
            the criteria provided by the element inspectors.
            </summary>
            <param name="elementInspectors">
            The element inspectors, which inspect each element in turn. The
            total number of element inspectors must exactly match the number of elements in the collection.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="elementInspectors"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="elementInspectors"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.SatisfyRespectively(System.Collections.Generic.IEnumerable{System.Action{`1}},System.String,System.Object[])">
            <summary>
            Asserts that a collection contains exactly a given number of elements, which meet
            the criteria provided by the element inspectors.
            </summary>
            <param name="expected">
            The element inspectors, which inspect each element in turn. The
            total number of element inspectors must exactly match the number of elements in the collection.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="expected"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Satisfy(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}}[])">
            <summary>
            Asserts that a collection contains exactly a given number of elements which meet
            the criteria provided by the element predicates. Assertion fails if it is not possible
            to find a one-to-one mapping between the elements of the collection and the predicates.
            The order of the predicates does not need to match the order of the elements.
            </summary>
            <param name="predicates">
            The predicates that the elements of the collection must match.
            The total number of predicates must exactly match the number of elements in the collection.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicates"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="predicates"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.Satisfy(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}}},System.String,System.Object[])">
            <summary>
            Asserts that a collection contains exactly a given number of elements which meet
            the criteria provided by the element predicates. Assertion fails if it is not possible
            to find a one-to-one mapping between the elements of the collection and the predicates.
            </summary>
            <param name="predicates">
            The predicates that the elements of the collection must match.
            The total number of predicates must exactly match the number of elements in the collection.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicates"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="predicates"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.StartWith(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the current collection starts with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectation"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.StartWith``1(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the current collection starts with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using <paramref name="equalityComparison"/>.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="equalityComparison">
            A equality comparison the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectation"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.StartWith(`1,System.String,System.Object[])">
            <summary>
            Asserts that the collection starts with the specified <paramref name="element"/>.
            </summary>
            <param name="element">
            The element that is expected to appear at the start of the collection. The object's <see cref="M:System.Object.Equals(System.Object)"/>
            is used to compare the element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.BeInOrder(System.Collections.Generic.IComparer{`1},FluentAssertions.Collections.SortOrder,System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in the specified <paramref name="expectedOrder"/>.
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`3.NotBeInOrder(System.Collections.Generic.IComparer{`1},FluentAssertions.Collections.SortOrder,System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.GenericDictionaryAssertions`3">
            <summary>
            Contains a number of methods to assert that a <typeparamref name="TCollection"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.GenericDictionaryAssertions`4">
            <summary>
            Contains a number of methods to assert that a <typeparamref name="TCollection"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.Equal``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains all the same key-value pairs as the
            specified <paramref name="expected"/> dictionary. Keys and values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected dictionary</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotEqual``1(``0,System.String,System.Object[])">
            <summary>
            Asserts the current dictionary not to contain all the same key-value pairs as the
            specified <paramref name="unexpected"/> dictionary. Keys and values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected dictionary</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.BeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that two dictionaries are equivalent.
            </summary>
            <remarks>
            The values within the dictionaries are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of the values in the dictionaries are ignored as long as both dictionaries contain the same keys and
            the values for each key are structurally equivalent. Notice that actual behavior is determined by the global
            defaults managed by the <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.BeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that two dictionaries are equivalent.
            </summary>
            <remarks>
            The values within the dictionaries are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of the values in the dictionaries are ignored as long as both dictionaries contain the same keys and
            the values for each key are structurally equivalent. Notice that actual behavior is determined by the global
            defaults managed by the <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.ContainKey(`1,System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains the specified key.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            </summary>
            <param name="expected">The expected key</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.ContainKeys(`1[])">
            <summary>
            Asserts that the dictionary contains all of the specified keys.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            </summary>
            <param name="expected">The expected keys</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.ContainKeys(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains all of the specified keys.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            </summary>
            <param name="expected">The expected keys</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContainKey(`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="unexpected" /> key.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            </summary>
            <param name="unexpected">The unexpected key</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContainKeys(`1[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified keys.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            </summary>
            <param name="unexpected">The unexpected keys</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContainKeys(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified keys.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            </summary>
            <param name="unexpected">The unexpected keys</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.ContainValue(`2,System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains the specified value. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.ContainValues(`2[])">
            <summary>
            Asserts that the dictionary contains all of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected values</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.ContainValues(System.Collections.Generic.IEnumerable{`2},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains all of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected values</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.RepetitionPreservingIntersect(System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Returns an enumerable consisting of all items in the first collection also appearing in the second.
            </summary>
            <remarks>Enumerable.Intersect is not suitable because it drops any repeated elements.</remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContainValue(`2,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="unexpected" /> value.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContainValues(`2[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected values</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContainValues(System.Collections.Generic.IEnumerable{`2},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected values</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.Contain(System.Collections.Generic.KeyValuePair{`1,`2}[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected key/value pairs.</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.Contain(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`1,`2}},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected key/value pairs.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.Contain(System.Collections.Generic.KeyValuePair{`1,`2},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.Contain(`1,`2,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="value" /> for the supplied
            <paramref name="key" />.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="key">The key for which to validate the value</param>
            <param name="value">The value to validate</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContain(System.Collections.Generic.KeyValuePair{`1,`2}[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="items"/>.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="items">The unexpected key/value pairs</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContain(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`1,`2}},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="items"/>.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="items">The unexpected key/value pairs</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContain(System.Collections.Generic.KeyValuePair{`1,`2},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="item"/>.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="item">The unexpected <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`4.NotContain(`1,`2,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="value" /> for the
            supplied <paramref name="key" />.
            Key comparison will honor the equality comparer of the dictionary when applicable.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="key">The key for which to validate the value</param>
            <param name="value">The value to validate</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.GenericDictionaryAssertions`4.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.MaximumMatching.Element`1">
            <summary>
            Stores an element's value and index in the maximum matching problem.
            </summary>
            <typeparam name="TValue">The type of the element value.</typeparam>
        </member>
        <member name="P:FluentAssertions.Collections.MaximumMatching.Element`1.Index">
            <summary>
            The index of the element in the maximum matching problem.
            </summary>
        </member>
        <member name="P:FluentAssertions.Collections.MaximumMatching.Element`1.Value">
            <summary>
            The value of the element in the maximum matching problem.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingProblem`1">
            <summary>
            The <see cref="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingProblem`1"/> class defines input for the maximum matching problem.
            The input is a list of predicates and a list of elements.
            The goal of the problem is to find such mapping between predicates and elements that would maximize number of matches.
            A predicate can be mapped with only one element.
            An element can be mapped with only one predicate.
            </summary>
            <typeparam name="TValue">The type of elements which must be matched with predicates.</typeparam>
        </member>
        <member name="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolution`1">
            <summary>
            The <see cref="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolution`1"/> class defines the solution (output) for the maximum matching problem.
            See documentation of <see cref="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingProblem`1"/> for more details.
            </summary>
            <typeparam name="TValue">The type of elements which must be matched with predicates.</typeparam>
        </member>
        <member name="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolver`1">
            <summary>
            The <see cref="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolver`1"/> class encapsulates the algorithm
            for solving the maximum matching problem (see <see cref="T:FluentAssertions.Collections.MaximumMatching.MaximumMatchingProblem`1"/>).
            See https://en.wikipedia.org/wiki/Maximum_cardinality_matching for more details.<br />
            A simplified variation of the Ford-Fulkerson algorithm is used for solving the problem.
            See https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm for more details.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolver`1.Solve">
            <summary>
            Solves the maximum matching problem;
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolver`1.FindMatchForPredicate(FluentAssertions.Collections.MaximumMatching.Predicate{`0},FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolver{`0}.MatchCollection)">
            <summary>
            To find a solution which contains the specified predicate and increases the total number of matches
            we: <br />
            - Search for a free element which matches the specified predicate.<br />
            - Or take over an element which was previously matched with another predicate and repeat the procedure for the previously matched predicate.<br />
            - We are basically searching for a path in the graph of matches between predicates and elements which would start at the specified predicate
            and end at an unmatched element.<br />
            - Breadth first search used to traverse the graph.<br />
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.MaximumMatching.Predicate`1">
            <summary>
            Stores a predicate's expression and index in the maximum matching problem.
            </summary>
            <typeparam name="TValue">The type of the element values in the maximum matching problems.</typeparam>
        </member>
        <member name="P:FluentAssertions.Collections.MaximumMatching.Predicate`1.Index">
            <summary>
            The index of the predicate in the maximum matching problem.
            </summary>
        </member>
        <member name="P:FluentAssertions.Collections.MaximumMatching.Predicate`1.Expression">
            <summary>
            The expression of the predicate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.MaximumMatching.Predicate`1.Matches(`0)">
            <summary>
            Determines whether the predicate matches the specified element.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Collections.StringCollectionAssertions"/> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Collections.StringCollectionAssertions`1"/> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Collections.StringCollectionAssertions`2"/> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.Equal(System.String[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="expected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.Equal(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="expected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.BeEquivalentTo(System.String[])">
            <summary>
            Asserts that a collection of string is equivalent to another collection of strings.
            </summary>
            <remarks>
            The two collections are equivalent when they both contain the same strings in any order.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.BeEquivalentTo(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            The two collections are equivalent when they both contain the same strings in any order.
            </remarks>
            <param name="expectation">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.BeEquivalentTo(System.Collections.Generic.IEnumerable{System.String},System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.String},FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.String}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            The two collections are equivalent when they both contain the same strings in any order.
            </remarks>
            <param name="expectation">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.AllBe(System.String,System.String,System.Object[])">
            <summary>
            Asserts that all strings in a collection of strings are equal to the given string.
            </summary>
            <param name="expectation">An expected <see cref="T:System.String"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.AllBe(System.String,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.String},FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.String}},System.String,System.Object[])">
            <summary>
            Asserts that all strings in a collection of strings are equal to the given string.
            </summary>
            <param name="expectation">An expected <see cref="T:System.String"/>.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.ContainMatch(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least one string that matches the <paramref name="wildcardPattern"/>.
            </summary>
            <param name="wildcardPattern">
            The pattern to match against the subject. This parameter can contain a combination of literal text and wildcard
            (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            <paramref name="wildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="wildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="wildcardPattern"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="wildcardPattern"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions`2.NotContainMatch(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any string that matches the <paramref name="wildcardPattern"/>.
            </summary>
            <param name="wildcardPattern">
            The pattern to match against the subject. This parameter can contain a combination of literal text and wildcard
            (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            <paramref name="wildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="wildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="wildcardPattern"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="wildcardPattern"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Collections.SubsequentOrderingGenericCollectionAssertions`3.ThenBeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a subsequence is ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.SubsequentOrderingGenericCollectionAssertions`3.ThenBeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a subsequence is ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.SubsequentOrderingGenericCollectionAssertions`3.ThenBeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a subsequence is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.SubsequentOrderingGenericCollectionAssertions`3.ThenBeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a subsequence is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            Empty and single element collections are considered to be ordered both in ascending and descending order at the same time.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.WhoseValueConstraint`4.#ctor(`3,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Collections.WhoseValueConstraint`4"/> class.
            </summary>
        </member>
        <member name="P:FluentAssertions.Collections.WhoseValueConstraint`4.WhoseValue">
            <summary>
            Gets the value of the object referred to by the key.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.Clock">
            <summary>
            Default implementation for <see cref="T:FluentAssertions.Common.IClock"/> for production use.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.Current">
            <summary>
            Gets the active configuration,
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode">
            <summary>
            Gets or sets the mode on how Fluent Assertions will find custom implementations of
            <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.ValueFormatterAssembly">
            <summary>
            Gets or sets the assembly name to scan for custom value formatters in case <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode"/>
            is set to <see cref="F:FluentAssertions.Common.ValueFormatterDetectionMode.Specific"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.TestFrameworkName">
            <summary>
            Gets or sets the name of the test framework to use.
            </summary>
            <remarks>
            If no name is provided, Fluent Assertions
            will try to detect it by scanning the currently loaded assemblies. If it can't find a suitable provider,
            and the run-time platform supports it, it'll try to get it from the <see cref="T:FluentAssertions.Common.IConfigurationStore"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Common.DateTimeExtensions.ToDateTimeOffset(System.DateTime)">
            <summary>
            Converts an existing <see cref="T:System.DateTime"/> to a <see cref="T:System.DateTimeOffset"/> but normalizes the <see cref="T:System.DateTimeKind"/>
            so that comparisons of converted <see cref="T:System.DateTime"/> instances retain the UTC/local agnostic behavior.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.EnumerableExtensions.IndexOfFirstDifferenceWith``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Searches for the first different element in two sequences using specified <paramref name="equalityComparison" />
            </summary>
            <typeparam name="TFirst">The type of the elements of the <paramref name="first" /> sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the <paramref name="second" /> sequence.</typeparam>
            <param name="first">The first sequence to compare.</param>
            <param name="second">The second sequence to compare.</param>
            <param name="equalityComparison">Method that is used to compare 2 elements with the same index.</param>
            <returns>Index at which two sequences have elements that are not equal, or -1 if enumerables are equal</returns>
        </member>
        <member name="M:FluentAssertions.Common.ExpressionExtensions.GetMemberPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets a dotted path of property names representing the property expression, including the declaring type.
            </summary>
            <example>
            E.g. Parent.Child.Sibling.Name.
            </example>
        </member>
        <member name="M:FluentAssertions.Common.ExpressionExtensions.ValidateMemberPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Validates that the expression can be used to construct a <see cref="T:FluentAssertions.Common.MemberPath"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.Guard.ValidatedNotNullAttribute">
            <summary>
            Workaround to make dotnet_code_quality.null_check_validation_methods work
            https://github.com/dotnet/roslyn-analyzers/issues/3451#issuecomment-606690452
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.IClock">
            <summary>
            Represents an abstract timer that is used to make some of this library's timing dependent functionality better testable.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.IClock.Delay(System.TimeSpan)">
            <summary>
            Will block the current thread until a time delay has passed.
            </summary>
            <param name="timeToDelay">The time span to wait before completing the returned task</param>
        </member>
        <member name="M:FluentAssertions.Common.IClock.DelayAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Creates a task that will complete after a time delay.
            </summary>
            <param name="delay">The time span to wait before completing the returned task</param>
            <param name="cancellationToken"></param>
            <returns>A task that represents the time delay.</returns>
            <seealso cref="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)"/>
        </member>
        <member name="M:FluentAssertions.Common.IClock.StartTimer">
            <summary>
            Creates a timer to measure the time to complete some arbitrary executions.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.Iterator`1">
            <summary>
            A smarter enumerator that can provide information about the relative location (current, first, last)
            of the current item within the collection without unnecessarily iterating the collection.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.ITimer">
            <summary>
            Abstracts a stopwatch so we can control time in unit tests.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.ITimer.Elapsed">
            <summary>
            The time elapsed since the timer was created through <see cref="M:FluentAssertions.Common.IClock.StartTimer"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.MemberPath">
            <summary>
            Encapsulates a dotted candidate to a (nested) member of a type as well as the
            declaring type of the deepest member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.MemberPath.IsParentOrChildOf(FluentAssertions.Common.MemberPath)">
            <summary>
            Gets a value indicating whether the current object represents a child member of the <paramref name="candidate"/>
            or that it is the parent of that candidate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.MemberPath.IsEquivalentTo(System.String)">
            <summary>
            Determines whether the current path is the same as <paramref name="path"/> when ignoring any specific indexes.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.MemberPath.GetContainsSpecificCollectionIndex">
            <summary>
            Gets a value indicating whether the current path contains an indexer like `[1]` instead of `[]`.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.MemberPath.MemberName">
            <summary>
            Returns the name of the member the current path points to without its parent path.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.MethodInfoExtensions.ImplementationOptionsMask">
            <summary>
            A sum of all possible <see cref="T:System.Runtime.CompilerServices.MethodImplOptions"/>. It's needed to calculate what options were used when decorating with <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/>.
            They are a subset of <see cref="T:System.Reflection.MethodImplAttributes"/> which can be checked on a type and therefore this mask has to be applied to check only for options.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.Services">
            <summary>
            Maintains the framework-specific services.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.StartTimer">
            <summary>
            Factory for starting a timer on demand.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexOfFirstMismatch(System.String,System.String,System.StringComparison)">
            <summary>
            Finds the first index at which the <paramref name="value"/> does not match the <paramref name="expected"/>
            string anymore, accounting for the specified <paramref name="stringComparison"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexedSegmentAt(System.String,System.Int32)">
            <summary>
            Gets the quoted three characters at the specified index of a string, including the index itself.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.WithoutSpecificCollectionIndices(System.String)">
            <summary>
            Replaces all numeric indices from a path like "property[0].nested" and returns "property[].nested"
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.ContainsSpecificCollectionIndex(System.String)">
            <summary>
            Determines whether a string contains a specific index like `[0]` instead of just `[]`.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.EscapePlaceholders(System.String)">
            <summary>
            Replaces all characters that might conflict with formatting placeholders with their escaped counterparts.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.UnescapePlaceholders(System.String)">
            <summary>
            Replaces all characters that might conflict with formatting placeholders with their escaped counterparts.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Combine(System.String,System.String,System.String)">
            <summary>
            Joins a string with one or more other strings using a specified separator.
            </summary>
            <remarks>
            Any string that is empty (including the original string) is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Capitalize(System.String)">
            <summary>
            Changes the first character of a string to uppercase.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndentLines(System.String)">
            <summary>
            Appends tab character at the beginning of each line in a string.
            </summary>
            <param name="this"></param>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.CountSubstring(System.String,System.String,System.StringComparison)">
            <summary>
            Counts the number of times a substring appears within a string by using the specified <see cref="T:System.StringComparison"/>.
            </summary>
            <param name="str">The string to search in.</param>
            <param name="substring">The substring to search for.</param>
            <param name="comparisonType">The <see cref="T:System.StringComparison"/> option to use for comparison.</param>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsEquivalentTo(FluentAssertions.Equivalency.IMember,FluentAssertions.Equivalency.IMember)">
            <summary>
            Determines whether two <see cref="T:FluentAssertions.Equivalency.IMember" /> objects refer to the same
            member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.GetClosedGenericInterfaces(System.Type,System.Type)">
            <summary>
            Returns the interfaces that the <paramref name="type"/> implements that are concrete
            versions of the <paramref name="openGenericType"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindProperty(System.Type,System.String,System.Type)">
            <summary>
            Finds the property by a case-sensitive name.
            </summary>
            <returns>
            Returns <c>null</c> if no such property exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindField(System.Type,System.String,System.Type)">
            <summary>
            Finds the field by a case-sensitive name.
            </summary>
            <returns>
            Returns <c>null</c> if no such property exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsCSharpAbstract(System.Type)">
            <summary>
            Check if the type is declared as abstract.
            </summary>
            <param name="type">Type to be checked</param>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsCSharpSealed(System.Type)">
            <summary>
            Check if the type is declared as sealed.
            </summary>
            <param name="type">Type to be checked</param>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsCSharpStatic(System.Type)">
            <summary>
            Check if the type is declared as static.
            </summary>
            <param name="type">Type to be checked</param>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.NullableOrActualType(System.Type)">
            <summary>
            If the type provided is a nullable type, gets the underlying type. Returns the type itself otherwise.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.ValueFormatterDetectionMode">
            <summary>
            Defines the modes in which custom implementations of <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>
            are detected as configured through <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode"/>.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Disabled">
            <summary>
            Detection is disabled.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Specific">
            <summary>
            Only custom value formatters exposed through the assembly set in <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterAssembly"/>
            are detected.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Scan">
            <summary>
            All custom value formatters in any assembly loaded in the current <see cref="T:System.AppDomain"/> will be detected.
            </summary>
        </member>
        <member name="T:FluentAssertions.CustomAssertionAttribute">
            <summary>
            Marks a method as an extension to Fluent Assertions that either uses the built-in assertions
            internally, or directly uses the <c>Execute.Assertion</c>.
            </summary>
        </member>
        <member name="T:FluentAssertions.DataRowAssertionExtensions">
            <summary>
            Contains an extension method for custom assertions in unit tests related to DataRow objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.DataRowAssertionExtensions.Should``1(``0)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Data.DataRowAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Data.DataRow"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.DataSetAssertionExtensions">
            <summary>
            Contains an extension method for custom assertions in unit tests related to DataSet objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.DataSetAssertionExtensions.Should``1(``0)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Data.DataSetAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Data.DataSet"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.DataTableAssertionExtensions">
            <summary>
            Contains an extension method for custom assertions in unit tests related to DataTable objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.DataTableAssertionExtensions.Should``1(``0)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Data.DataTableAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Data.DataTable"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Data.DataColumnAssertions">
            <summary>
            Provides convenient assertion methods on a <see cref="T:System.Data.DataColumn"/> that can be
            used to assert equivalency.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.DataColumnAssertions.BeEquivalentTo(System.Data.DataColumn,System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataColumn"/> is equivalent to another.
             </summary>
             <remarks>
             Data columns are equivalent when the following members have the same values:
            
             <list type="bullet">
               <item><description>AllowDBNull</description></item>
               <item><description>AutoIncrement</description></item>
               <item><description>AutoIncrementSeed</description></item>
               <item><description>AutoIncrementStep</description></item>
               <item><description>Caption</description></item>
               <item><description>ColumnName</description></item>
               <item><description>DataType</description></item>
               <item><description>DateTimeMode</description></item>
               <item><description>DefaultValue</description></item>
               <item><description>Expression</description></item>
               <item><description>ExtendedProperties</description></item>
               <item><description>MaxLength</description></item>
               <item><description>Namespace</description></item>
               <item><description>Prefix</description></item>
               <item><description>ReadOnly</description></item>
               <item><description>Unique</description></item>
             </list>
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="M:FluentAssertions.Data.DataColumnAssertions.BeEquivalentTo(System.Data.DataColumn,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataColumn},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataColumn}},System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataColumn"/> is equivalent to another.
             </summary>
             <remarks>
             Data columns are equivalent when the following members have the same values:
            
             <list type="bullet">
               <item><description>AllowDBNull</description></item>
               <item><description>AutoIncrement</description></item>
               <item><description>AutoIncrementSeed</description></item>
               <item><description>AutoIncrementStep</description></item>
               <item><description>Caption</description></item>
               <item><description>ColumnName</description></item>
               <item><description>DataType</description></item>
               <item><description>DateTimeMode</description></item>
               <item><description>DefaultValue</description></item>
               <item><description>Expression</description></item>
               <item><description>ExtendedProperties</description></item>
               <item><description>MaxLength</description></item>
               <item><description>Namespace</description></item>
               <item><description>Prefix</description></item>
               <item><description>ReadOnly</description></item>
               <item><description>Unique</description></item>
             </list>
            
             Testing of any property can be overridden using the <paramref name="config"/> callback. Exclude specific properties using
             <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>.
            
             If <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumn(System.Data.DataColumn)"/> or a related function is
             used and the exclusion matches the subject <see cref="T:System.Data.DataColumn"/>, then the equivalency test will never
             fail.
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="config">
             A reference to the <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> configuration object that can be used
             to influence the way the object graphs are compared. You can also provide an alternative instance of the
             <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
             <see cref="T:FluentAssertions.AssertionOptions"/> class.
             </param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="T:FluentAssertions.Data.DataRowAssertions`1">
            <summary>
            Provides convenient assertion methods on a <see cref="T:System.Data.DataRow"/> that can be
            used to assert equivalency and the presence of columns.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.DataRowAssertions`1.HaveColumn(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataRow"/> has a column with the expected column name.
            </summary>
            <param name="expectedColumnName">The value that is expected in <see cref="P:System.Data.DataColumn.ColumnName"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataRowAssertions`1.HaveColumns(System.String[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataRow"/> has columns with all of the supplied expected column names.
            </summary>
            <param name="expectedColumnNames">An array of values expected in <see cref="P:System.Data.DataColumn.ColumnName"/>.</param>
        </member>
        <member name="M:FluentAssertions.Data.DataRowAssertions`1.HaveColumns(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataRow"/> has columns with all of the supplied expected column names.
            </summary>
            <param name="expectedColumnNames">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of string values expected in <see cref="P:System.Data.DataColumn.ColumnName"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataRowAssertions`1.BeEquivalentTo(System.Data.DataRow,System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataRow"/> is equivalent to another.
             </summary>
             <remarks>
             Data rows are equivalent when they contain identical field data for the row they represent, and
             the following members have the same values:
            
             <list type="bullet">
               <item><description>HasErrors</description></item>
               <item><description>RowState</description></item>
             </list>
            
             The <see cref="T:System.Data.DataRow"/> objects must be of the same type; if two <see cref="T:System.Data.DataRow"/> objects
             are equivalent in all ways, except that one is part of a typed <see cref="T:System.Data.DataTable"/> and is of a subclass
             of <see cref="T:System.Data.DataRow"/>, then by default, they will not be considered equivalent. This can be overridden
             with the <see cref="M:FluentAssertions.Data.DataRowAssertions`1.BeEquivalentTo(System.Data.DataRow,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataRow},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataRow}},System.String,System.Object[])"/>
             overload.
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="M:FluentAssertions.Data.DataRowAssertions`1.BeEquivalentTo(System.Data.DataRow,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataRow},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataRow}},System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataRow"/> is equivalent to another.
             </summary>
             <remarks>
             Data rows are equivalent when they contain identical field data for the row they represent, and
             the following members have the same values:
            
             <list type="bullet">
               <item><description>HasErrors</description></item>
               <item><description>RowState</description></item>
             </list>
            
             The <see cref="T:System.Data.DataRow"/> objects must be of the same type; if two <see cref="T:System.Data.DataRow"/> objects
             are equivalent in all ways, except that one is part of a typed <see cref="T:System.Data.DataTable"/> and is of a subclass
             of <see cref="T:System.Data.DataRow"/>, then by default, they will not be considered equivalent.
            
             This, as well as testing of any property can be overridden using the <paramref name="config"/> callback.
             By calling <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.AllowingMismatchedTypes"/>, two <see cref="T:System.Data.DataRow"/>
             objects of differing types can be considered equivalent. Exclude specific properties using
             <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>.
             Exclude columns of the data table (which also excludes the related field data in <see cref="T:System.Data.DataRow"/>
             objects) using <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumn(System.Data.DataColumn)"/> or a related function.
             </remarks>
            
             You can use <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataTable,System.Object}})"/>
             and related functions to exclude properties on other related System.Data types.
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="config">
             A reference to the <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> configuration object that can be used
             to influence the way the object graphs are compared. You can also provide an alternative instance of the
             <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
             <see cref="T:FluentAssertions.AssertionOptions"/> class.
             </param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="T:FluentAssertions.Data.DataSetAssertions`1">
            <summary>
            Provides convenient assertion methods on a <see cref="T:System.Data.DataSet"/> that can be
            used to assert equivalency and the presence of tables.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.DataSetAssertions`1.HaveTableCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataSet"/> contains exactly the expected number of tables in its <see cref="P:System.Data.DataSet.Tables"/> collection.
            </summary>
            <param name="expected">The expected number of rows.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataSetAssertions`1.HaveTable(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataSet"/> contains a table with the expected name.
            </summary>
            <param name="expectedTableName">The value that is expected in <see cref="P:System.Data.DataTable.TableName"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataSetAssertions`1.HaveTables(System.String[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataSet"/> has tables with all of the supplied expected column names.
            </summary>
            <param name="expectedTableNames">An array of values expected in <see cref="P:System.Data.DataTable.TableName"/>.</param>
        </member>
        <member name="M:FluentAssertions.Data.DataSetAssertions`1.HaveTables(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataSet"/> has tables with all of the supplied expected table names.
            </summary>
            <param name="expectedTableNames">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of string values expected in <see cref="P:System.Data.DataTable.TableName"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataSetAssertions`1.BeEquivalentTo(System.Data.DataSet,System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataSet"/> is equivalent to another.
             </summary>
             <remarks>
             Data sets are equivalent when their <see cref="P:System.Data.DataSet.Tables"/> and <see cref="P:System.Data.DataSet.ExtendedProperties"/>
             collections are equivalent and the following members have the same values:
            
             <list type="bullet">
               <item><description>DataSetName</description></item>
               <item><description>CaseSensitive</description></item>
               <item><description>EnforceConstraints</description></item>
               <item><description>HasErrors</description></item>
               <item><description>Locale</description></item>
               <item><description>Namespace</description></item>
               <item><description>Prefix</description></item>
               <item><description>RemotingFormat</description></item>
               <item><description>SchemaSerializationMode</description></item>
             </list>
            
             The <see cref="T:System.Data.DataSet"/> objects must be of the same type; if two <see cref="T:System.Data.DataSet"/> objects
             are equivalent in all ways, except that one is a custom subclass of <see cref="T:System.Data.DataSet"/> (e.g. to provide
             typed accessors for <see cref="T:System.Data.DataTable"/> values contained by the <see cref="T:System.Data.DataSet"/>), then by default,
             they will not be considered equivalent. This can be overridden with the
             <see cref="M:FluentAssertions.Data.DataSetAssertions`1.BeEquivalentTo(System.Data.DataSet,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataSet},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataSet}},System.String,System.Object[])"/>
             overload.
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="M:FluentAssertions.Data.DataSetAssertions`1.BeEquivalentTo(System.Data.DataSet,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataSet},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataSet}},System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataSet"/> is equivalent to another.
             </summary>
             <remarks>
             Data sets are equivalent when their <see cref="P:System.Data.DataSet.Tables"/> and <see cref="P:System.Data.DataSet.ExtendedProperties"/>
             collections are equivalent and the following members have the same values:
            
             <list type="bullet">
               <item><description>DataSetName</description></item>
               <item><description>CaseSensitive</description></item>
               <item><description>EnforceConstraints</description></item>
               <item><description>HasErrors</description></item>
               <item><description>Locale</description></item>
               <item><description>Namespace</description></item>
               <item><description>Prefix</description></item>
               <item><description>RemotingFormat</description></item>
               <item><description>SchemaSerializationMode</description></item>
             </list>
            
             The <see cref="T:System.Data.DataSet"/> objects must be of the same type; if two <see cref="T:System.Data.DataSet"/> objects
             are equivalent in all ways, except that one is a custom subclass of <see cref="T:System.Data.DataSet"/> (e.g. to provide
             typed accessors for <see cref="T:System.Data.DataTable"/> values contained by the <see cref="T:System.Data.DataSet"/>), then by default,
             they will not be considered equivalent.
            
             This, as well as testing of any property can be overridden using the <paramref name="config"/> callback.
             By calling <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.AllowingMismatchedTypes"/>, two <see cref="T:System.Data.DataSet"/>
             objects of differing types can be considered equivalent. This setting applies to all types recursively tested
             as part of the <see cref="T:System.Data.DataSet"/>.
            
             Exclude specific properties using <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>.
             Exclude specific tables within the data set using <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingTable(System.String)"/>
             or a related function. You can also indicate that columns should be excluded within the <see cref="T:System.Data.DataTable"/>
             objects recursively tested as part of the <see cref="T:System.Data.DataSet"/> using <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumn(System.Data.DataColumn)"/>
             or a related function. The <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumnInAllTables(System.String)"/> method
             can be used to exclude columns across all <see cref="T:System.Data.DataTable"/> objects in the <see cref="T:System.Data.DataSet"/> that share
             the same name.
            
             You can use <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataTable,System.Object}})"/>
             and related functions to exclude properties on other related System.Data types.
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="config">
             A reference to the <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> configuration object that can be used
             to influence the way the object graphs are compared. You can also provide an alternative instance of the
             <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
             <see cref="T:FluentAssertions.AssertionOptions"/> class.
             </param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="T:FluentAssertions.Data.DataTableAssertions`1">
            <summary>
            Provides convenient assertion methods on a <see cref="T:System.Data.DataTable"/> that can be
            used to assert equivalency and the presence of rows and columns.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.DataTableAssertions`1.HaveRowCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataTable"/> contains exactly the expected number of rows in its <see cref="P:System.Data.DataTable.Rows"/> collection.
            </summary>
            <param name="expected">The expected number of rows.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataTableAssertions`1.HaveColumn(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataTable"/> has a column with the expected column name.
            </summary>
            <param name="expectedColumnName">The value that is expected in <see cref="P:System.Data.DataColumn.ColumnName"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataTableAssertions`1.HaveColumns(System.String[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataTable"/> has columns with all of the supplied expected column names.
            </summary>
            <param name="expectedColumnNames">An array of values expected in <see cref="P:System.Data.DataColumn.ColumnName"/>.</param>
        </member>
        <member name="M:FluentAssertions.Data.DataTableAssertions`1.HaveColumns(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that an instance of <see cref="T:System.Data.DataTable"/> has columns with all of the supplied expected column names.
            </summary>
            <param name="expectedColumnNames">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of string values expected in <see cref="P:System.Data.DataColumn.ColumnName"/>.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Data.DataTableAssertions`1.BeEquivalentTo(System.Data.DataTable,System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataTable"/> is equivalent to another.
             </summary>
             <remarks>
             Data tables are equivalent when the following members have the same values:
            
             <list type="bullet">
               <item><description>TableName</description></item>
               <item><description>CaseSensitive</description></item>
               <item><description>DisplayExpression</description></item>
               <item><description>HasErrors</description></item>
               <item><description>Locale</description></item>
               <item><description>Namespace</description></item>
               <item><description>Prefix</description></item>
               <item><description>RemotingFormat</description></item>
             </list>
            
             In addition, the following collections must contain equivalent data:
            
             <list type="type=bullet">
               <item><description>ChildRelations</description></item>
               <item><description>Columns</description></item>
               <item><description>Constraints</description></item>
               <item><description>ExtendedProperties</description></item>
               <item><description>ParentRelations</description></item>
               <item><description>PrimaryKey</description></item>
               <item><description>Rows</description></item>
             </list>
            
             The <see cref="T:System.Data.DataTable"/> objects must be of the same type; if two <see cref="T:System.Data.DataTable"/> objects
             are equivalent in all ways, except that one is a typed <see cref="T:System.Data.DataTable"/> that is a subclass
             of <see cref="T:System.Data.DataTable"/>, then by default, they will not be considered equivalent. This can be overridden
             with the <see cref="M:FluentAssertions.Data.DataTableAssertions`1.BeEquivalentTo(System.Data.DataTable,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataTable},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataTable}},System.String,System.Object[])"/>
             overload.
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="M:FluentAssertions.Data.DataTableAssertions`1.BeEquivalentTo(System.Data.DataTable,System.Func{FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataTable},FluentAssertions.Data.IDataEquivalencyAssertionOptions{System.Data.DataTable}},System.String,System.Object[])">
             <summary>
             Asserts that an instance of <see cref="T:System.Data.DataTable"/> is equivalent to another.
             </summary>
             <remarks>
             Data tables are equivalent when the following members have the same values:
            
             <list type="bullet">
               <item><description>TableName</description></item>
               <item><description>CaseSensitive</description></item>
               <item><description>DisplayExpression</description></item>
               <item><description>HasErrors</description></item>
               <item><description>Locale</description></item>
               <item><description>Namespace</description></item>
               <item><description>Prefix</description></item>
               <item><description>RemotingFormat</description></item>
             </list>
            
             In addition, the following collections must contain equivalent data:
            
             <list type="type=bullet">
               <item><description>ChildRelations</description></item>
               <item><description>Columns</description></item>
               <item><description>Constraints</description></item>
               <item><description>ExtendedProperties</description></item>
               <item><description>ParentRelations</description></item>
               <item><description>PrimaryKey</description></item>
               <item><description>Rows</description></item>
             </list>
            
             The <see cref="T:System.Data.DataTable"/> objects must be of the same type; if two <see cref="T:System.Data.DataTable"/> objects
             are equivalent in all ways, except that one is a typed <see cref="T:System.Data.DataTable"/> that is a subclass
             of <see cref="T:System.Data.DataTable"/>, then by default, they will not be considered equivalent.
            
             This, as well as testing of any property can be overridden using the <paramref name="config"/> callback.
             By calling <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.AllowingMismatchedTypes"/>, two <see cref="T:System.Data.DataTable"/>
             objects of differing types can be considered equivalent. Exclude specific properties using
             <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>.
             Exclude columns of the data table using <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumn(System.Data.DataColumn)"/>
             or a related function -- this excludes both the <see cref="T:System.Data.DataColumn"/> objects in <see cref="P:System.Data.DataTable.Columns"/>
             and associated field data in <see cref="T:System.Data.DataRow"/> objects within the <see cref="T:System.Data.DataTable"/>.
            
             You can use <see cref="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataTable,System.Object}})"/>
             and related functions to exclude properties on other related System.Data types.
             </remarks>
             <param name="expectation">A <see cref="T:System.Data.DataColumn"/> with the expected configuration.</param>
             <param name="config">
             A reference to the <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> configuration object that can be used
             to influence the way the object graphs are compared. You can also provide an alternative instance of the
             <see cref="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
             <see cref="T:FluentAssertions.AssertionOptions"/> class.
             </param>
             <param name="because">
             A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
             is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
             </param>
             <param name="becauseArgs">
             Zero or more objects to format using the placeholders in <paramref name="because"/>.
             </param>
        </member>
        <member name="T:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1">
            <summary>
            Provides access to configuration for equivalency assertions on System.Data types (<see cref="T:System.Data.DataSet"/>,
            <see cref="T:System.Data.DataTable"/>, <see cref="T:System.Data.DataRow"/>, <see cref="T:System.Data.DataColumn"/>, <see cref="T:System.Data.DataRelation"/>,
            <see cref="T:System.Data.Constraint"/>).
            </summary>
            <typeparam name="T">The System.Data type being tested for equivalency.</typeparam>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.AllowingMismatchedTypes">
            <summary>
            Specifies that the subject and the expectation should not be considered non-equivalent if their exact data types do not match.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.IgnoringUnmatchedColumns">
            <summary>
            Specifies that when comparing <see cref="P:System.Data.DataTable.Columns"/>, columns that are unmatched between the subject and the expectation should be ignored.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.UsingRowMatchMode(FluentAssertions.Data.RowMatchMode)">
            <summary>
            Specifies the <see cref="T:FluentAssertions.Data.RowMatchMode"/> that should be used when comparing <see cref="P:System.Data.DataTable.Rows"/>. By default, rows are matched by their index in the <see cref="P:System.Data.DataTable.Rows"/> collection. But, if the <see cref="T:System.Data.DataTable"/> has a <see cref="P:System.Data.DataTable.PrimaryKey"/> set, it is possible to use <see cref="F:FluentAssertions.Data.RowMatchMode.PrimaryKey"/> to indicate that rows should be matched by their primary key values, irrespective of their index within the <see cref="P:System.Data.DataTable.Rows"/> collection.
            </summary>
            <param name="rowMatchMode">The <see cref="T:FluentAssertions.Data.RowMatchMode"/> to use when comparing <see cref="P:System.Data.DataTable.Rows"/> between the subject and the expectation.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingOriginalData">
            <summary>
            Specifies that when comparing <see cref="T:System.Data.DataRow"/> objects that are in the <see cref="F:System.Data.DataRowState.Modified"/> state, only the current field values should be compared. Original field values are excluded from comparison. This only affects comparisons where both the subject and the expectation are in the modified state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
            Excludes members of the objects under test from comparison by means of a predicate that selects members based on <see cref="T:FluentAssertions.Equivalency.IMemberInfo"/> objects describing them.
            </summary>
            <param name="predicate">A functor that returns true if the <see cref="T:FluentAssertions.Equivalency.IMemberInfo"/> parameter refers to a member that should be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Excludes a member of the objects under test from comparison by means of an <see cref="T:System.Linq.Expressions.Expression`1"/> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingTable(System.String)">
            <summary>
            Excludes an entire table from comparison. When comparing <see cref="T:System.Data.DataSet"/> objects, if a table is present by the supplied name, it is not considered for the purpose of determining equivalency. This configuration option has no effect when comparing other types of object, including <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="tableName">The value for <see cref="P:System.Data.DataTable.TableName"/> for which tables within a <see cref="T:System.Data.DataSet"/> should be ignored.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingTables(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Excludes tables from comparison using names in an <see cref="T:System.Collections.Generic.IEnumerable`1"/> set. When comparing <see cref="T:System.Data.DataSet"/> objects, if a table is present by one of the supplied names, it is not considered for the purpose of determining equivalency. This configuration option has no effect when comparing other types of object, including <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="tableNames">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.String"/> values for <see cref="P:System.Data.DataTable.TableName"/> for which tables within a <see cref="T:System.Data.DataSet"/> should be ignored.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingTables(System.String[])">
            <summary>
            Excludes tables from comparison using an array of table names. When comparing <see cref="T:System.Data.DataSet"/> objects, if a table is present by one of the supplied names, it is not considered for the purpose of determining equivalency. This configuration option has no effect when comparing other types of object, including <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="tableNames">An array of <see cref="T:System.String"/> values for <see cref="P:System.Data.DataTable.TableName"/> for which tables within a <see cref="T:System.Data.DataSet"/> should be ignored.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumn(System.Data.DataColumn)">
            <summary>
            Excludes a column from comparison by <see cref="T:System.Data.DataColumn"/>. The column to be excluded is matched by the name of its associated <see cref="T:System.Data.DataTable"/> and its own <see cref="P:System.Data.DataColumn.ColumnName"/>.
            </summary>
            <param name="column">A <see cref="T:System.Data.DataColumn"/> object that specifies which column should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumn(System.String,System.String)">
            <summary>
            Excludes a column from comparison by the name of its associated <see cref="T:System.Data.DataTable"/> and its own <see cref="P:System.Data.DataColumn.ColumnName"/>.
            </summary>
            <param name="tableName">The value for <see cref="P:System.Data.DataTable.TableName"/> for which columns should be ignored.</param>
            <param name="columnName">The value for <see cref="P:System.Data.DataColumn.ColumnName"/> for which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumns(System.Collections.Generic.IEnumerable{System.Data.DataColumn})">
            <summary>
            Exclude an enumerable set of columns from comparison by <see cref="T:System.Data.DataColumn"/>. For each item in the enumeration, the column to be excluded is matched by the name of its associated <see cref="T:System.Data.DataTable"/> and its own <see cref="P:System.Data.DataColumn.ColumnName"/>.
            </summary>
            <param name="columns">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> object that specifies which column(s) should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumns(System.Data.DataColumn[])">
            <summary>
            Excludes an array of columns from comparison by <see cref="T:System.Data.DataColumn"/>. For each element in the array, the column to be excluded is matched by the name of its associated <see cref="T:System.Data.DataTable"/> and its own <see cref="P:System.Data.DataColumn.ColumnName"/>.
            </summary>
            <param name="columns">An array of <see cref="T:System.Data.DataColumn"/> objects that specify which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumns(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Excludes an enumerable set of columns from comparison by name, within tables with a specified name./>.
            </summary>
            <param name="tableName">The value for <see cref="P:System.Data.DataTable.TableName"/> for which columns should be ignored.</param>
            <param name="columnNames">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.String"/> values that specify the <see cref="P:System.Data.DataColumn.ColumnName"/> values for which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumns(System.String,System.String[])">
            <summary>
            Excludes an array of columns from comparison by name, within tables with a specified name./>.
            </summary>
            <param name="tableName">The value for <see cref="P:System.Data.DataTable.TableName"/> for which columns should be ignored.</param>
            <param name="columnNames">An array of <see cref="T:System.String"/> values that specify the <see cref="P:System.Data.DataColumn.ColumnName"/> values for which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumnInAllTables(System.String)">
            <summary>
            Excludes columns from comparison by <see cref="T:System.Data.DataColumn"/> comparing only the <see cref="P:System.Data.DataColumn.ColumnName"/>. If columns exist by the same name in multiple <see cref="T:System.Data.DataTable"/> objects within a <see cref="T:System.Data.DataSet"/>, they are all excluded from comparison.
            </summary>
            <param name="columnName">The value for <see cref="P:System.Data.DataColumn.ColumnName"/> for which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumnsInAllTables(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Excludes columns from comparison by <see cref="T:System.Data.DataColumn"/> comparing only the <see cref="P:System.Data.DataColumn.ColumnName"/>. If columns exist by the same name in multiple <see cref="T:System.Data.DataTable"/> objects within a <see cref="T:System.Data.DataSet"/>, they are all excluded from comparison.
            </summary>
            <param name="columnNames">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.String"/> values that specify the <see cref="P:System.Data.DataColumn.ColumnName"/> values for which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingColumnsInAllTables(System.String[])">
            <summary>
            Excludes columns from comparison by <see cref="T:System.Data.DataColumn"/> comparing only the <see cref="P:System.Data.DataColumn.ColumnName"/>. If columns exist by the same name in multiple <see cref="T:System.Data.DataTable"/> objects within a <see cref="T:System.Data.DataSet"/>, they are all excluded from comparison.
            </summary>
            <param name="columnNames">An array of <see cref="T:System.String"/> values that specify the <see cref="P:System.Data.DataColumn.ColumnName"/> values for which columns should be ignored.</param>
            <remarks>
            When comparing <see cref="T:System.Data.DataColumn"/> objects (e.g. within <see cref="T:System.Data.DataColumnCollection"/>), excluded columns are ignored completely. When comparing <see cref="T:System.Data.DataRow"/> objects, the data associated with excluded columns is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.Constraint,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.Constraint"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.ForeignKeyConstraint,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.Constraint"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.UniqueConstraint,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.Constraint"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataColumn,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.DataColumn"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataRelation,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.DataRelation"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataRow,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.DataRow"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="M:FluentAssertions.Data.IDataEquivalencyAssertionOptions`1.ExcludingRelated(System.Linq.Expressions.Expression{System.Func{System.Data.DataTable,System.Object}})">
            <summary>
            Excludes properties of <see cref="T:System.Data.DataTable"/> from comparison by means of an<see cref= "T:System.Linq.Expressions.Expression`1" /> that refers to the member in question.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression`1"/> that accesses the member to be excluded.</param>
        </member>
        <member name="T:FluentAssertions.Data.RowMatchMode">
            <summary>
            Indicates how <see cref="T:System.Data.DataRow"/> objects from different <see cref="T:System.Data.DataTable"/> objects should be matched
            up for equivalency comparisons.
            </summary>
        </member>
        <member name="F:FluentAssertions.Data.RowMatchMode.Index">
            <summary>
            Indicates that <see cref="T:System.Data.DataRow"/> objects should be matched up by their index within the
            <see cref="P:System.Data.DataTable.Rows"/> collection. This is the default.
            </summary>
        </member>
        <member name="F:FluentAssertions.Data.RowMatchMode.PrimaryKey">
            <summary>
            Indicates that <see cref="T:System.Data.DataRow"/> objects should be matched up by the values they have for
            the table's <see cref="P:System.Data.DataTable.PrimaryKey"/>. For this to work, the rows must be from
            <see cref="T:System.Data.DataTable"/> objects with exactly equivalent <see cref="P:System.Data.DataTable.PrimaryKey"/>
            configuration.
            </summary>
        </member>
        <member name="T:FluentAssertions.EnumAssertionsExtensions">
            <summary>
            Contains an extension method for custom assertions in unit tests related to Enum objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.EnumAssertionsExtensions.Should``1(``0)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.EnumAssertions`2"/> object that can be used to assert the
            current <typeparamref name="TEnum"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EnumAssertionsExtensions.Should``1(System.Nullable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.EnumAssertions`2"/> object that can be used to assert the
            current <typeparamref name="TEnum"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.EquivalencyPlan">
            <summary>
            Represents a mutable collection of equivalency steps that can be reordered and/or amended with additional
            custom equivalency steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyPlan.Add``1">
            <summary>
            Adds a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> after any of the built-in steps, with the exception of the final
            <see cref="T:FluentAssertions.Equivalency.Steps.SimpleEqualityEquivalencyStep"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyPlan.AddAfter``2">
            <summary>
            Adds a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> right after the specified <typeparamref name="TPredecessor"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyPlan.Insert``1">
            <summary>
            Inserts a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> before any of the built-in steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyPlan.InsertBefore``2">
            <summary>
            Inserts a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> just before the <typeparamref name="TSuccessor"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyPlan.Remove``1">
            <summary>
            Removes all instances of the specified <typeparamref name="TStep"/> from the current step.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyPlan.Clear">
            <summary>
            Removes each and every built-in <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Comparands.Subject">
            <summary>
            Gets the value of the subject object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Comparands.Expectation">
            <summary>
            Gets the value of the expected object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Comparands.RuntimeType">
            <summary>
            Gets the run-time type of the current expectation object.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Comparands.GetExpectedType(FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Returns either the run-time or compile-time type of the expectation based on the options provided by the caller.
            </summary>
            <remarks>
            If the expectation is a nullable type, it should return the type of the wrapped object.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.ConversionSelector">
            <summary>
            Collects the members that need to be converted by the <see cref="T:FluentAssertions.Equivalency.Steps.AutoConversionStep"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.CyclicReferenceHandling">
            <summary>
            Indication of how cyclic references should be handled when validating equality of nested properties.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.CyclicReferenceHandling.Ignore">
            <summary>
            Cyclic references will be ignored.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.CyclicReferenceHandling.ThrowException">
            <summary>
            Cyclic references will result in an exception.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1">
            <summary>
            Represents the run-time type-specific behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Excludes the specified (nested) member from the structural equality check.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Including(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Includes the specified member in the equality check.
            </summary>
            <remarks>
            This overrides the default behavior of including all declared members.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Causes the collection identified by <paramref name="expression"/> to be compared in the order
            in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.AsCollection">
            <summary>
            Creates a new set of options based on the current instance which acts on a a collection of the <typeparamref name="TExpectation"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithMapping``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Maps a (nested) property or field of type <typeparamref name="TExpectation"/> to
            a (nested) property or field of <typeparamref name="TSubject"/> using lambda expressions.
            </summary>
            <param name="expectationMemberPath">A field or property expression indicating the (nested) member to map from.</param>
            <param name="subjectMemberPath">A field or property expression indicating the (nested) member to map to.</param>
            <remarks>
            The members of the subject and the expectation must have the same parent. Also, indexes in collections are ignored.
            If the types of the members are different, the usual logic applies depending or not if conversion options were specified.
            Fields can be mapped to properties and vice-versa.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithMapping(System.String,System.String)">
            <summary>
            Maps a (nested) property or field of the expectation to a (nested) property or field of the subject using a path string.
            </summary>
            <param name="expectationMemberPath">
            A field or property path indicating the (nested) member to map from in the format <c>Parent.Child.Collection[].Member</c>.
            </param>
            <param name="subjectMemberPath">
            A field or property path indicating the (nested) member to map to in the format <c>Parent.Child.Collection[].Member</c>.
            </param>
            <remarks>
            The members of the subject and the expectation must have the same parent. Also, indexes in collections are not allowed
            and must be written as "[]".  If the types of the members are different, the usual logic applies depending or not
            if conversion options were specified.
            Fields can be mapped to properties and vice-versa.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithMapping``2(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Linq.Expressions.Expression{System.Func{``1,System.Object}})">
            <summary>
            Maps a direct property or field of type <typeparamref name="TNestedExpectation"/> to
            a direct property or field of <typeparamref name="TNestedSubject"/> using lambda expressions.
            </summary>
            <param name="expectationMember">A field or property expression indicating the member to map from.</param>
            <param name="subjectMember">A field or property expression indicating the member to map to.</param>
            <remarks>
            Only direct members of <typeparamref name="TNestedExpectation"/> and <typeparamref name="TNestedSubject"/> can be
            mapped to each other. Those types can appear anywhere in the object graphs that are being compared.
            If the types of the members are different, the usual logic applies depending or not if conversion options were specified.
            Fields can be mapped to properties and vice-versa.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithMapping``2(System.String,System.String)">
            <summary>
            Maps a direct property or field of type <typeparamref name="TNestedExpectation"/> to
            a direct property or field of <typeparamref name="TNestedSubject"/> using member names.
            </summary>
            <param name="expectationMemberName">A field or property name indicating the member to map from.</param>
            <param name="subjectMemberName">A field or property name indicating the member to map to.</param>
            <remarks>
            Only direct members of <typeparamref name="TNestedExpectation"/> and <typeparamref name="TNestedSubject"/> can be
            mapped to each other, so no <c>.</c> or <c>[]</c> are allowed.
            Those types can appear anywhere in the object graphs that are being compared.
            If the types of the members are different, the usual logic applies depending or not if conversion options were specified.
            Fields can be mapped to properties and vice-versa.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions">
            <summary>
            Represents the run-time type-agnostic behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyStep`1">
            <summary>
             Convenient implementation of <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> that will only invoke
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyStep`1.OnHandle(FluentAssertions.Equivalency.Comparands,FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator)">
            <summary>
            Implements <see cref="M:FluentAssertions.Equivalency.IEquivalencyStep.Handle(FluentAssertions.Equivalency.Comparands,FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator)"/>, but only gets called when the expected type matches <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyValidationContext">
            <summary>
            Provides information on a particular property during an assertion for structural equality of two object graphs.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyValidator">
            <summary>
            Is responsible for validating the equality of one or more properties of a subject with another object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Execution.CollectionMemberAssertionOptionsDecorator">
            <summary>
            Ensures that all the rules remove the collection index from the path before processing it further.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Execution.CyclicReferenceDetector">
            <summary>
            Keeps track of objects and their location within an object graph so that cyclic references can be detected
            and handled upon.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Execution.CyclicReferenceDetector.IsCyclicReference(FluentAssertions.Equivalency.Execution.ObjectReference,FluentAssertions.Equivalency.CyclicReferenceHandling,FluentAssertions.Execution.Reason)">
            <summary>
            Determines whether the specified object reference is a cyclic reference to the same object earlier in the
            equivalency validation.
            </summary>
            <remarks>
            The behavior of a cyclic reference is determined by the <paramref name="handling"/> parameter.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.Execution.CyclicReferenceDetector.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.Execution.ObjectReference">
            <summary>
            Represents  an object tracked by the <see cref="T:FluentAssertions.Equivalency.Execution.CyclicReferenceDetector"/> including it's location within an object graph.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Execution.ObjectReference.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.Execution.ObjectReference.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Field">
            <summary>
            A specialized type of <see cref="T:FluentAssertions.Equivalency.INode"/> that represents a field of an object in a structural equivalency assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IAssertionContext`1">
            <summary>
            Provides the required information for executing an equality assertion between a subject and an expectation.
            </summary>
            <typeparam name="TSubject">The type of the subject.</typeparam>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.SelectedNode">
            <summary>
            Gets the <see cref="T:FluentAssertions.Equivalency.IMember"/> of the member that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Subject">
            <summary>
            Gets the value of the <see cref="P:FluentAssertions.Equivalency.IAssertionContext`1.SelectedNode" />
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Expectation">
            <summary>
            Gets the value of the expectation object that was matched with the subject using a <see cref="T:FluentAssertions.Equivalency.IMemberMatchingRule"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Because">
            <summary>
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.BecauseArgs">
            <summary>
            Zero or more objects to format using the placeholders in <see cref="P:FluentAssertions.Equivalency.IAssertionContext`1.Because" />.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyAssertionOptions">
            <summary>
            Provides the run-time details of the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1" /> class.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.SelectionRules">
            <summary>
            Gets an ordered collection of selection rules that define what members (e.g. properties or fields) are included.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.MatchingRules">
            <summary>
            Gets an ordered collection of matching rules that determine which subject members are matched with which
            expectation properties.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IsRecursive">
            <summary>
            Gets a value indicating whether or not the assertion must perform a deep comparison.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.AllowInfiniteRecursion">
            <summary>
            Gets a value indicating whether recursion is allowed to continue indefinitely.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.CyclicReferenceHandling">
            <summary>
            Gets value indicating how cyclic references should be handled. By default, it will throw an exception.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.OrderingRules">
            <summary>
            Gets an ordered collection of rules that determine whether or not the order of collections is important. By default,
            ordering is irrelevant.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.ConversionSelector">
            <summary>
            Contains the rules for what properties to run an auto-conversion.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.EnumEquivalencyHandling">
            <summary>
            Gets value indicating how the enums should be compared.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UserEquivalencySteps">
            <summary>
            Gets an ordered collection of Equivalency steps how a subject is compared with the expectation.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UseRuntimeTyping">
            <summary>
            Gets a value indicating whether the runtime type of the expectation should be used rather than the declared type.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludedProperties">
            <summary>
            Gets a value indicating whether and which properties should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludedFields">
            <summary>
            Gets a value indicating whether and which fields should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.CompareRecordsByValue">
            <summary>
            Gets a value indicating whether records should be compared by value instead of their members
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.TraceWriter">
            <summary>
            Gets the currently configured tracer, or <c>null</c> if no tracing was configured.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.GetEqualityStrategy(System.Type)">
            <summary>
            Determines the right strategy for evaluating the equality of objects of this type.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.Equals">
            <summary>
            The object overrides <see cref="M:System.Object.Equals(System.Object)"/>, so use that.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.Members">
            <summary>
            The object does not seem to override <see cref="M:System.Object.Equals(System.Object)"/>, so compare by members
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.ForceEquals">
            <summary>
            Compare using <see cref="M:System.Object.Equals(System.Object)"/>, whether or not the object overrides it.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.ForceMembers">
            <summary>
            Compare the members, regardless of an <see cref="M:System.Object.Equals(System.Object)"/> override exists or not.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyStep">
            <summary>
            Defines a step in the process of comparing two object graphs for structural equivalency.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyStep.Handle(FluentAssertions.Equivalency.Comparands,FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator)">
            <summary>
            Executes an operation such as an equivalency assertion on the provided <paramref name="comparands"/>.
            </summary>
            <value>
            Should return <see cref="F:FluentAssertions.Equivalency.EquivalencyResult.AssertionCompleted"/> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <see cref="F:FluentAssertions.Equivalency.EquivalencyResult.ContinueWithNext"/> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyValidationContext">
            <summary>
            Provides information on a particular property or field during an assertion for structural equality of two object graphs.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.CurrentNode">
            <summary>
            Gets the <see cref="T:FluentAssertions.Equivalency.INode"/> of the member that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Reason">
            <summary>
            A formatted phrase and the placeholder values explaining why the assertion is needed.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Tracer">
            <summary>
            Gets an object that can be used by the equivalency algorithm to provide a trace when the
            <see cref="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithTracing(FluentAssertions.Equivalency.Tracing.ITraceWriter)"/> option is used.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.IsCyclicReference(System.Object)">
            <summary>
            Determines whether the specified object reference is a cyclic reference to the same object earlier in the
            equivalency validation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.AsNestedMember(FluentAssertions.Equivalency.IMember)">
            <summary>
            Creates a context from the current object intended to assert the equivalency of a nested member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.AsCollectionItem``1(System.String)">
            <summary>
            Creates a context from the current object intended to assert the equivalency of a collection item identified by <paramref name="index"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.AsDictionaryItem``2(``0)">
            <summary>
            Creates a context from the current object intended to assert the equivalency of a collection item identified by <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.Clone">
            <summary>
            Creates a deep clone of the current context.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidator.RecursivelyAssertEquality(FluentAssertions.Equivalency.Comparands,FluentAssertions.Equivalency.IEquivalencyValidationContext)">
            <summary>
            Runs a deep recursive equivalency assertion on the provided <paramref name="comparands"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMember">
            <summary>
            Exposes information about an object's member
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMember.DeclaringType">
            <summary>
            Gets the type that declares the current member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMember.ReflectedType">
            <summary>
            Gets the type that was used to determine this member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMember.GetValue(System.Object)">
            <summary>
            Gets the value of the member from the provided <paramref name="obj"/>
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMember.GetterAccessibility">
            <summary>
            Gets the access modifier for the getter of this member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMember.SetterAccessibility">
            <summary>
            Gets the access modifier for the setter of this member.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberInfo">
            <summary>
            Represents a field or property in an object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.Name">
            <summary>
            Gets the name of the current member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.Type">
            <summary>
            Gets the type of this member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.DeclaringType">
            <summary>
            Gets the type that declares the current member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.Path">
            <summary>
            Gets the full path from the root object until and including the current node separated by dots.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.GetterAccessibility">
            <summary>
            Gets the access modifier for the getter of this member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.SetterAccessibility">
            <summary>
            Gets the access modifier for the setter of this member.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberMatchingRule">
            <summary>
            Represents a rule that defines how to map the selected members of the expectation object to the properties
            of the subject.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMemberMatchingRule.Match(FluentAssertions.Equivalency.IMember,System.Object,FluentAssertions.Equivalency.INode,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Attempts to find a member on the subject that should be compared with the
            <paramref name="expectedMember"/> during a structural equality.
            </summary>
            <remarks>
            Whether or not a match is required or optional is up to the specific rule. If no match is found and this is not an issue,
            simply return <c>null</c>.
            </remarks>
            <param name="expectedMember">
            The <see cref="T:FluentAssertions.Equivalency.IMember"/> of the subject's member for which a match must be found. Can never
            be <c>null</c>.
            </param>
            <param name="subject">
            The subject object for which a matching member must be returned. Can never be <c>null</c>.
            </param>
            <param name="parent"></param>
            <param name="options"></param>
            <returns>
            Returns the <see cref="T:FluentAssertions.Equivalency.IMember"/> of the property with which to compare the subject with, or <c>null</c>
            if no match was found.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberSelectionRule">
            <summary>
            Represents a rule that defines which members of the expectation to include while comparing
            two objects for structural equality.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberSelectionRule.IncludesMembers">
            <summary>
            Gets a value indicating whether this rule should override the default selection rules that include all members.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMemberSelectionRule.SelectMembers(FluentAssertions.Equivalency.INode,System.Collections.Generic.IEnumerable{FluentAssertions.Equivalency.IMember},FluentAssertions.Equivalency.MemberSelectionContext)">
            <summary>
            Adds or removes properties or fields to/from the collection of members that must be included while
            comparing two objects for structural equality.
            </summary>
            <param name="currentNode">
                The node within the graph from which to select members.
            </param>
            <param name="selectedMembers">
                A collection of members that was pre-populated by other selection rules. Can be empty.</param>
            <param name="context">Provides auxiliary information such as the configuration and such.</param>
            <returns>
            The collection of members after applying this rule. Can contain less or more than was passed in.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.INode">
            <summary>
            Represents a node in the object graph as it is expected in a structural equivalency check.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.GetSubjectId">
            <summary>
            The name of the variable on which a structural equivalency assertion is executed or
            the default if reflection failed.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.Name">
            <summary>
            Gets the name of this node.
            </summary>
            <example>
            "Property2"
            </example>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.Type">
            <summary>
            Gets the type of this node.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.Path">
            <summary>
            Gets the path from the root object UNTIL the current node, separated by dots or index/key brackets.
            </summary>
            <example>
            "Parent[0].Property2"
            </example>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.PathAndName">
            <summary>
            Gets the full path from the root object up to and including the name of the node.
            </summary>
            <example>
            "Parent[0]"
            </example>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.Depth">
            <summary>
            Gets a zero-based number representing the depth within the object graph
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.Description">
            <summary>
            Gets the path including the description of the subject.
            </summary>
            <example>
            "property subject.Parent[0].Property2"
            </example>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.IsRoot">
            <summary>
            Gets a value indicating whether the current node is the root.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.INode.RootIsCollection">
            <summary>
            Gets a value indicating if the root of this graph is a collection.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.GetSubjectId">
            <summary>
            Allows deferred fetching of the subject ID.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IObjectInfo">
            <summary>
            Represents an object, dictionary key pair, collection item or member in an object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IObjectInfo.Type">
            <summary>
            Gets the type of this node.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IObjectInfo.Path">
            <summary>
            Gets the full path from the root object until the current node separated by dots.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IObjectInfo.CompileTimeType">
            <summary>
            Gets the compile-time type of the current object. If the current object is not the root object and the type is not <see cref="T:System.Object"/>,
            then it returns the same <see cref="T:System.Type"/> as the <see cref="P:FluentAssertions.Equivalency.IObjectInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IObjectInfo.RuntimeType">
            <summary>
            Gets the run-time type of the current object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IOrderingRule">
            <summary>
            Defines a rule that is used to determine whether the order of items in collections is relevant or not.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IOrderingRule.Evaluate(FluentAssertions.Equivalency.IObjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="objectInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.MappedMemberMatchingRule`2">
            <summary>
            Allows mapping a member (property or field) of the expectation to a differently named member
            of the subject-under-test using a member name and the target type.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.MappedPathMatchingRule">
            <summary>
            Allows mapping a member (property or field) of the expectation to a differently named member
            of the subject-under-test using a nested member path in the form of "Parent.NestedCollection[].Member"
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.MustMatchByNameRule">
            <summary>
            Requires the subject to have a member with the exact same name as the expectation has.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Matching.MustMatchByNameRule.ToString">
            <inheritdoc />
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.TryMatchByNameRule">
            <summary>
            Finds a member of the expectation with the exact same name, but doesn't require it.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Matching.TryMatchByNameRule.ToString">
            <inheritdoc />
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.MemberSelectionContext">
            <summary>
            Provides contextual information to an <see cref="T:FluentAssertions.Equivalency.IMemberSelectionRule"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.MemberSelectionContext.IncludedProperties">
            <summary>
            Gets a value indicating whether and which properties should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.MemberSelectionContext.IncludedFields">
            <summary>
            Gets a value indicating whether and which fields should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.MemberSelectionContext.Type">
            <summary>
            Gets either the compile-time or run-time type depending on the options provided by the caller.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.MemberVisibility">
            <summary>
            Determines which members are included in the equivalency assertion
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.MultiDimensionalArrayEquivalencyStep">
            <summary>
            Supports recursively comparing two multi-dimensional arrays for equivalency using strict order for the array items
            themselves.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Node">
            <summary>
            Represents a node in the object graph that is being compared as part of a structural equivalency check.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.OrderingRuleCollection">
            <summary>
            Collection of <see cref="T:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule"/>s.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.#ctor">
            <summary>
            Initializes a new collection of ordering rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.#ctor(System.Collections.Generic.IEnumerable{FluentAssertions.Equivalency.IOrderingRule})">
            <summary>
            Initializes a new collection of ordering rules based on an existing collection of ordering rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.IsOrderingStrictFor(FluentAssertions.Equivalency.IObjectInfo)">
            <summary>
            Determines whether the rules in this collection dictate strict ordering during the equivalency assertion on
            the collection pointed to by <paramref name="objectInfo"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.ByteArrayOrderingRule">
            <summary>
            Ordering rule that ensures that byte arrays are always compared in strict ordering since it would cause a
            severe performance impact otherwise.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule">
            <summary>
            An ordering rule that basically states that the order of items in all collections is important.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule.Evaluate(FluentAssertions.Equivalency.IObjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="objectInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule">
            <summary>
            Represents a rule for determining whether or not a certain collection within the object graph should be compared using
            strict ordering.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule.Evaluate(FluentAssertions.Equivalency.IObjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="objectInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Property">
            <summary>
            A specialized type of <see cref="T:FluentAssertions.Equivalency.INode"/> that represents a property of an object in a structural equivalency assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.AllFieldsSelectionRule">
            <summary>
            Selection rule that adds all public fields of the expectation
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.AllFieldsSelectionRule.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.AllPropertiesSelectionRule">
            <summary>
            Selection rule that adds all public properties of the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.AllPropertiesSelectionRule.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.ExcludeMemberByPathSelectionRule">
            <summary>
            Selection rule that removes a particular property from the structural comparison.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule">
            <summary>
            Selection rule that removes a particular member from the structural comparison based on a predicate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule.ToString">
            <inheritdoc />
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.IncludeMemberByPathSelectionRule">
            <summary>
            Selection rule that includes a particular property in the structural comparison.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule">
            <summary>
            Selection rule that includes a particular member in the structural comparison.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule.ToString">
            <inheritdoc />
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.MemberToMemberInfoAdapter">
            <summary>
            Represents a selection context of a nested property
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1">
            <summary>
            Represents the run-time behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.#ctor(FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Creates an instance of the equivalency assertions options based on defaults previously configured by the caller.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#SelectionRules">
            <summary>
            Gets an ordered collection of selection rules that define what members are included.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#MatchingRules">
            <summary>
            Gets an ordered collection of matching rules that determine which subject members are matched with which
            expectation members.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#UserEquivalencySteps">
            <summary>
            Gets an ordered collection of Equivalency steps how a subject is compared with the expectation.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#OrderingRules">
            <summary>
            Gets an ordered collection of rules that determine whether or not the order of collections is important. By
            default,
            ordering is irrelevant.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#IsRecursive">
            <summary>
            Gets value indicating whether the equality check will include nested collections and complex types.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#CyclicReferenceHandling">
            <summary>
            Gets value indicating how cyclic references should be handled. By default, it will throw an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingAllDeclaredProperties">
            <summary>
            Causes inclusion of only public properties of the subject as far as they are defined on the declared type.
            </summary>
            <remarks>
            This clears all previously registered selection rules.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingAllRuntimeProperties">
            <summary>
            Causes inclusion of only public properties of the subject based on its run-time type rather than its declared type.
            </summary>
            <remarks>
            This clears all previously registered selection rules.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingFields">
            <summary>
            Instructs the comparison to include public fields.
            </summary>
            <remarks>
            This is part of the default behavior.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingInternalFields">
            <summary>
            Instructs the comparison to include public and internal fields.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingFields">
            <summary>
            Instructs the comparison to exclude fields.
            </summary>
            <remarks>
            This does not preclude use of `Including`.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingProperties">
            <summary>
            Instructs the comparison to include public properties.
            </summary>
            <remarks>
            This is part of the default behavior.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingInternalProperties">
            <summary>
            Instructs the comparison to include public and internal properties.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingProperties">
            <summary>
            Instructs the comparison to exclude properties.
            </summary>
            <remarks>
            This does not preclude use of `Including`.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.RespectingRuntimeTypes">
            <summary>
            Instructs the comparison to respect the expectation's runtime type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.RespectingDeclaredTypes">
            <summary>
            Instructs the comparison to respect the expectation's declared type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
            Excludes a (nested) property based on a predicate from the structural equality check.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Including(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
            Includes the specified member in the equality check.
            </summary>
            <remarks>
            This overrides the default behavior of including all declared members.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingMissingMembers">
            <summary>
            Tries to match the members of the subject with equally named members on the expectation. Ignores those
            members that don't exist on the expectation and previously registered matching rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ThrowingOnMissingMembers">
            <summary>
            Requires the subject to have members which are equally named to members on the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using``1(System.Action{FluentAssertions.Equivalency.IAssertionContext{``0}})">
            <summary>
            Overrides the comparison of subject and expectation to use provided <paramref name="action"/>
            when the predicate is met.
            </summary>
            <param name="action">
            The assertion to execute when the predicate is met.
            </param>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingNestedObjects">
            <summary>
            Causes the structural equality check to include nested collections and complex types.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingNestedObjects">
            <summary>
            Causes the structural equality check to exclude nested collections and complex types.
            </summary>
            <remarks>
            Behaves similarly to the old property assertions API.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IgnoringCyclicReferences">
            <summary>
            Causes the structural equality check to ignore any cyclic references.
            </summary>
            <remarks>
            By default, cyclic references within the object graph will cause an exception to be thrown.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.AllowingInfiniteRecursion">
            <summary>
            Disables limitations on recursion depth when the structural equality check is configured to include nested objects
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutSelectionRules">
            <summary>
            Clears all selection rules, including those that were added by default.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutMatchingRules">
            <summary>
            Clears all matching rules, including those that were added by default.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMemberSelectionRule)">
            <summary>
            Adds a selection rule to the ones already added by default, and which is evaluated after all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMemberMatchingRule)">
            <summary>
            Adds a matching rule to the ones already added by default, and which is evaluated before all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IOrderingRule)">
            <summary>
            Adds an ordering rule to the ones already added by default, and which is evaluated after all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IEquivalencyStep)">
            <summary>
            Adds an equivalency step rule to the ones already added by default, and which is evaluated before previous
            user-registered steps
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using``2">
            <summary>
            Ensures the equivalency comparison will create and use an instance of <typeparamref name="TEqualityComparer"/>
            that implements <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>, any time
            when a property is of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Ensures the equivalency comparison will use the specified implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            any time when a property is of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithStrictOrdering">
            <summary>
            Causes all collections to be compared in the order in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IObjectInfo,System.Boolean}})">
            <summary>
            Causes the collection identified by the provided <paramref name="predicate" /> to be compared in the order
            in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutStrictOrdering">
            <summary>
            Causes all collections - except bytes - to be compared ignoring the order in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IObjectInfo,System.Boolean}})">
            <summary>
            Causes the collection identified by the provided <paramref name="predicate" /> to be compared ignoring the order
            in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingEnumsByName">
            <summary>
            Causes to compare Enum properties using the result of their ToString method.
            </summary>
            <remarks>
            By default, enums are compared by value.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingEnumsByValue">
            <summary>
            Causes to compare Enum members using their underlying value only.
            </summary>
            <remarks>
            This is the default.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingRecordsByValue">
            <summary>
            Ensures records by default are compared by value instead of their members.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingRecordsByMembers">
            <summary>
            Ensures records by default are compared by value instead of their members.
            </summary>
            <remarks>
            This is the default.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByMembers``1">
            <summary>
            Marks the <typeparamref name="T" /> as a type that should be compared by its members even though it may override
            the <see cref="M:System.Object.Equals(System.Object)" /> method.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByMembers(System.Type)">
            <summary>
            Marks <paramref name="type" /> as a type that should be compared by its members even though it may override
            the <see cref="M:System.Object.Equals(System.Object)" /> method.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByValue``1">
            <summary>
            Marks the <typeparamref name="T" /> as a value type which must be compared using its
            <see cref="M:System.Object.Equals(System.Object)" /> method, regardless of it overriding it or not.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByValue(System.Type)">
            <summary>
            Marks <paramref name="type" /> as a value type which must be compared using its
            <see cref="M:System.Object.Equals(System.Object)" /> method, regardless of it overriding it or not.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithTracing(FluentAssertions.Equivalency.Tracing.ITraceWriter)">
            <summary>
            Enables tracing the steps the equivalency validation followed to compare two graphs.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithAutoConversion">
            <summary>
            Instructs the equivalency comparison to try to convert the values of
            matching properties before running any of the other steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithAutoConversionFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IObjectInfo,System.Boolean}})">
            <summary>
            Instructs the equivalency comparison to try to convert the value of
            a specific member on the expectation object before running any of the other steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutAutoConversionFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IObjectInfo,System.Boolean}})">
            <summary>
            Instructs the equivalency comparison to prevent trying to convert the value of
            a specific member on the expectation object before running any of the other steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1">
            <summary>
            Defines additional overrides when used with <see cref="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1" />
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1.WhenTypeIs``1">
            <summary>
            Allows overriding the way structural equality is applied to (nested) objects of type
            <typeparamref name="TMemberType" />
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1.When(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IObjectInfo,System.Boolean}})">
            <summary>
            Allows overriding the way structural equality is applied to particular members.
            </summary>
            <param name="predicate">
            A predicate based on the <see cref="T:FluentAssertions.Equivalency.IMemberInfo" /> of the subject that is used to identify the property for which
            the
            override applies.
            </param>
        </member>
        <member name="T:FluentAssertions.Equivalency.Steps.AssertionResultSet">
            <summary>
            Represents a collection of assertion results obtained through a <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.AssertionResultSet.AddSet(System.Object,System.String[])">
            <summary>
            Adds the failures (if any) resulting from executing an assertion within a
            <see cref="T:FluentAssertions.Execution.AssertionScope"/> identified by a key.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.AssertionResultSet.SelectClosestMatchFor(System.Object)">
            <summary>
            Returns  the closest match compared to the set identified by the provided <paramref name="key"/> or
            an empty array if one of the results represents a successful assertion.
            </summary>
            <remarks>
            The closest match is the set that contains the least amount of failures, or no failures at all, and preferably
            the set that is identified by the <paramref name="key"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.AssertionResultSet.ContainsSuccessfulSet">
            <summary>
            Gets a value indicating whether this collection contains a set without any failures at all.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.AssertionRuleEquivalencyStep`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Steps.AutoConversionStep">
            <summary>
            Attempts to convert the subject's property value to the expected type.
            </summary>
            <remarks>
            Whether or not the conversion is attempted depends on the <see cref="T:FluentAssertions.Equivalency.ConversionSelector"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo">
            <summary>
            Provides Reflection-backed meta-data information about a type implementing the <see cref="T:System.Collections.Generic.IDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo.TryGetFrom(System.Type,System.String,FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo@)">
            <summary>
            Tries to reflect on the provided <paramref name="target"/> and returns an instance of the <see cref="T:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo"/>
            representing the single dictionary interface. Will throw if the target implements more than one dictionary interface.
            </summary>
            <remarks>>
            The <paramref name="role"/> is used to describe the <paramref name="target"/> in failure messages.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo.TryGetFromWithKey(System.Type,System.String,System.Type,FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo@)">
            <summary>
            Tries to reflect on the provided <paramref name="target"/> and returns an instance of the <see cref="T:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo"/>
            representing the single dictionary interface keyed to <paramref name="key"/>.
            Will throw if the target implements more than one dictionary interface.
            </summary>
            <remarks>>
            The <paramref name="role"/> is used to describe the <paramref name="target"/> in failure messages.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo.TryConvertFrom(System.Object,System.Object@)">
            <summary>
            Tries to convert an object into a dictionary typed to the <see cref="P:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo.Key"/> and <see cref="P:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo.Value"/> of the current <see cref="T:FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo"/>.
            </summary>
            <returns>
            <c>true</c> if the conversion succeeded or <c>false</c> otherwise.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.Steps.EnumerableEquivalencyValidator">
            <summary>
            Executes a single equivalency assertion on two collections, optionally recursive and with or without strict ordering.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Steps.RunAllUserStepsEquivalencyStep">
            <summary>
            Represents a composite equivalency step that passes the execution to all user-supplied steps that can handle the
            current context.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Steps.ValueTypeEquivalencyStep">
            <summary>
            Ensures that types that are marked as value types are treated as such.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichSetterHas(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info setter has the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info setter should have.</param>
            <returns>True if the subject info setter has the given access modifier, false otherwise.</returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichSetterDoesNotHave(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info setter does not have the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info setter should not have.</param>
            <returns>True if the subject info setter does not have the given access modifier, false otherwise.</returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichGetterHas(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info getter has the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info getter should have.</param>
            <returns>True if the subject info getter has the given access modifier, false otherwise.</returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichGetterDoesNotHave(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info getter does not have the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info getter should not have.</param>
            <returns>True if the subject info getter does not have the given access modifier, false otherwise.</returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.Tracing.GetTraceMessage">
            <summary>
            Defines a function that takes the full path from the root object until the current object
            in the equivalency operation separated by dots, and returns the trace message to log.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Tracing.ITraceWriter">
            <summary>
            Represents an object that is used by the <see cref="T:FluentAssertions.Equivalency.Tracing.Tracer"/> class to receive tracing statements on what is
            happening during a structural equivalency comparison.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Tracing.ITraceWriter.AddSingle(System.String)">
            <summary>
            Writes a single line to the trace.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Tracing.ITraceWriter.AddBlock(System.String)">
            <summary>
            Starts a block that scopes an operation that should be written to the trace after the returned <see cref="T:System.IDisposable"/>
            is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Tracing.ITraceWriter.ToString">
            <summary>
            Returns a copy of the trace.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Tracing.Tracer">
            <summary>
            Exposes tracing capabilities that can be used by the implementation of the equivalency algorithm
            when an <see cref="T:FluentAssertions.Equivalency.Tracing.ITraceWriter"/> is provided.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Tracing.Tracer.WriteLine(FluentAssertions.Equivalency.Tracing.GetTraceMessage)">
            <summary>
            Writes a single line to the currently configured <see cref="T:FluentAssertions.Equivalency.Tracing.ITraceWriter"/>.
            </summary>
            <remarks>
            If no tracer has been configured, the call will be ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.Tracing.Tracer.WriteBlock(FluentAssertions.Equivalency.Tracing.GetTraceMessage)">
            <summary>
            Starts a block that scopes an operation that will be written to the currently configured <see cref="T:FluentAssertions.Equivalency.Tracing.ITraceWriter"/>
            after the returned disposable is disposed.
            </summary>
            <remarks>
            If no tracer has been configured for the <see cref="T:FluentAssertions.Equivalency.IEquivalencyValidationContext"/>, the call will be ignored.
            </remarks>
        </member>
        <member name="T:FluentAssertions.EventRaisingExtensions">
            <summary>
            Provides extension methods for monitoring and querying events.
            </summary>
        </member>
        <member name="M:FluentAssertions.EventRaisingExtensions.WithSender(FluentAssertions.Events.IEventRecording,System.Object)">
            <summary>
            Asserts that all occurrences of the event originated from the <param name="expectedSender"/> and
            returns only the events that came from that sender.
            </summary>
        </member>
        <member name="M:FluentAssertions.EventRaisingExtensions.WithArgs``1(FluentAssertions.Events.IEventRecording,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Asserts that at least one occurrence of the events had at least one of the arguments matching a predicate. Returns
            only the events that matched that predicate.
            </summary>
        </member>
        <member name="M:FluentAssertions.EventRaisingExtensions.WithArgs``1(FluentAssertions.Events.IEventRecording,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}}[])">
            <summary>
            Asserts that at least one of the occurred events has arguments the match the predicates in the same order. Returns
            only the events that matched those predicates.
            </summary>
            <remarks>
            If a <c>null</c> is provided as predicate argument, the corresponding event parameter value is ignored.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Events.EventAssertions`1">
            <summary>
            Provides convenient assertion methods on a <see cref="T:FluentAssertions.Events.IMonitor`1"/> that can be
            used to assert that certain events have been raised.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.Raise(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an object has raised a particular event at least once.
            </summary>
            <param name="eventName">
            The name of the event that should have been raised.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.NotRaise(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an object has not raised a particular event.
            </summary>
            <param name="eventName">
            The name of the event that should not be raised.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.RaisePropertyChangeFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that an object has raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <param name="propertyExpression">
            A lambda expression referring to the property for which the property changed event should have been raised, or
            <c>null</c> to refer to all properties.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.NotRaisePropertyChangeFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that an object has not raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <param name="propertyExpression">
            A lambda expression referring to the property for which the property changed event should have been raised.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Events.EventHandlerFactory">
            <summary>
            Static methods that aid in generic event subscription
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.GenerateHandler(System.Type,FluentAssertions.Events.EventRecorder)">
            <summary>
            Generates an eventhandler for an event of type eventSignature that calls RegisterEvent on recorder
            when invoked.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.GetDelegateReturnType(System.Type)">
            <summary>
            Finds the Return Type of a Delegate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.GetDelegateParameterTypes(System.Type)">
            <summary>
            Returns an Array of Types that make up a delegate's parameter signature.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.AppendParameterListThisReference(System.Type[])">
            <summary>
            Returns an array of types appended with an EventRecorder reference at the beginning.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.TypeIsDelegate(System.Type)">
            <summary>
            Returns T/F Dependent on a Type Being a Delegate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.DelegateInvokeMethod(System.Type)">
            <summary>
            Returns the MethodInfo for the Delegate's "Invoke" Method.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventMetadata">
            <summary>
            Provides the metadata of a monitored event.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventMetadata.EventName">
            <summary>
            The name of the event member on the monitored object
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventMetadata.HandlerType">
            <summary>
            The type of the event handler and event args.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventMonitor`1">
            <summary>
            Tracks the events an object raises.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventRecorder">
            <summary>
            Records activity for a single event.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.#ctor(System.Object,System.String,System.Func{System.DateTime},FluentAssertions.Events.ThreadSafeSequenceGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Events.EventRecorder"/> class.
            </summary>
            <param name="eventRaiser">The object events are recorded from</param>
            <param name="eventName">The name of the event that's recorded</param>
            <param name="utcNow">A delegate to get the current date and time in UTC format.</param>
            <param name="sequenceGenerator">Class used to generate a sequence in a thread-safe manner.</param>
        </member>
        <member name="P:FluentAssertions.Events.EventRecorder.EventObject">
            <summary>
            The object events are recorded from
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventRecorder.EventName">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.RecordEvent(System.Object[])">
            <summary>
            Called by the auto-generated IL, to record information about a raised event.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.Reset">
            <summary>
            Resets recorder to clear records of events raised so far.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.IEventRecording">
            <summary>
            Represents an (active) recording of all events that happen(ed) while monitoring an object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecording.EventObject">
            <summary>
            The object events are recorded from
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecording.EventName">
            <summary>
            The name of the event that's recorded
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecording.EventHandlerType">
            <summary>
            The type of the event handler identified by <see cref="P:FluentAssertions.Events.IEventRecording.EventName"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.IMonitor`1">
            <summary>
            Monitors events on a given source
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IMonitor`1.Subject">
            <summary>
            Gets the object that is being monitored or <c>null</c> if the object has been GCed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IMonitor`1.Clear">
            <summary>
            Clears all recorded events from the monitor and continues monitoring.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IMonitor`1.Should">
            <summary>
            Provides access to several assertion methods.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IMonitor`1.MonitoredEvents">
            <summary>
            Gets the metadata of all the events that are currently being monitored.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IMonitor`1.OccurredEvents">
            <summary>
            Gets a collection of all events that have occurred since the monitor was created or
            <see cref="M:FluentAssertions.Events.IMonitor`1.Clear"/> was called.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.OccurredEvent">
            <summary>
            Represents an occurrence of a particular event.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.EventName">
            <summary>
            The name of the event as defined on the monitored object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.Parameters">
            <summary>
            The parameters that were passed to the event handler.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.TimestampUtc">
            <summary>
            The exact date and time of the occurrence in <see cref="F:System.DateTimeKind.Local"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.Sequence">
            <summary>
            The order in which this event was raised on the monitored object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.RecordedEvent">
            <summary>
            This class is used to store data about an intercepted event
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.RecordedEvent.#ctor(System.DateTime,System.Int32,System.Object[])">
            <summary>
            Default constructor stores the parameters the event was raised with
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.RecordedEvent.TimestampUtc">
            <summary>
            The exact data and time in UTC format at which the event occurred.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.RecordedEvent.Parameters">
            <summary>
            Parameters for the event
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.RecordedEvent.Sequence">
            <summary>
            The order in which this event was invoked on the monitored object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.ThreadSafeSequenceGenerator">
            <summary>
            Generates a sequence in a thread-safe manner.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.ThreadSafeSequenceGenerator.Increment">
            <summary>
            Increments the current sequence.
            </summary>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithMessage``1(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.String,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception has a message that matches <paramref name="expectedWildcardPattern" />.
            </summary>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="expectedWildcardPattern">
            The wildcard pattern with which the exception message is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.Where``1(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the exception matches a particular condition.
            </summary>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="exceptionExpression">
            The condition that the exception must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithInnerException``2(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of type <typeparamref name="TInnerException" />.
            </summary>
            <typeparam name="TException">The expected type of the exception.</typeparam>
            <typeparam name="TInnerException">The expected type of the inner exception.</typeparam>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithInnerException``1(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of type <param name="innerException" />.
            </summary>
            <typeparam name="TException">The expected type of the exception.</typeparam>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithInnerExceptionExactly``2(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of the exact type <typeparamref name="TInnerException" /> (and not a derived exception type).
            </summary>
            <typeparam name="TException">The expected type of the exception.</typeparam>
            <typeparam name="TInnerException">The expected type of the inner exception.</typeparam>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithInnerExceptionExactly``1(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of the exact type <param name="innerException" /> (and not a derived exception type).
            </summary>
            <typeparam name="TException">The expected type of the exception.</typeparam>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithParameterName``1(FluentAssertions.Specialized.ExceptionAssertions{``0},System.String,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception has a parameter which name matches <paramref name="paramName" />.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="paramName">The expected name of the parameter</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.ExceptionAssertionsExtensions.WithParameterName``1(System.Threading.Tasks.Task{FluentAssertions.Specialized.ExceptionAssertions{``0}},System.String,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception has a parameter which name matches <paramref name="paramName" />.
            </summary>
            <param name="task">The <see cref="T:FluentAssertions.Specialized.ExceptionAssertions`1"/> containing the thrown exception.</param>
            <param name="paramName">The expected name of the parameter</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Execution.AssertionFailedException">
            <summary>
            Represents the default exception in case no test framework is configured.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.AssertionScope">
            <summary>
            Represents an implicit or explicit scope within which multiple assertions can be collected.
            </summary>
            <remarks>
            This class is supposed to have a very short life time and is not safe to be used in assertion that cross thread-boundaries
            such as when using <c>async</c> or <c>await</c>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(System.String)">
            <summary>
            Starts a named scope within which multiple assertions can be executed
            and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor">
            <summary>
            Starts an unnamed scope within which multiple assertions can be executed
            and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(FluentAssertions.Execution.IAssertionStrategy)">
            <summary>
            Starts a new scope based on the given assertion strategy.
            </summary>
            <param name="assertionStrategy">The assertion strategy for this scope.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when trying to use a null strategy.</exception>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(System.Lazy{System.String})">
            <summary>
            Starts a named scope within which multiple assertions can be executed
            and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(FluentAssertions.Execution.IAssertionStrategy,FluentAssertions.Execution.AssertionScope)">
            <summary>
            Starts a new scope based on the given assertion strategy and parent assertion scope
            </summary>
            <param name="assertionStrategy">The assertion strategy for this scope.</param>
            <param name="parent">The parent assertion scope for this scope.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when trying to use a null strategy.</exception>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Context">
            <summary>
            Gets or sets the context of the current assertion scope, e.g. the path of the object graph
            that is being asserted on. The context is provided by a <see cref="T:System.Lazy`1"/> which
            only gets evaluated when its value is actually needed (in most cases during a failure).
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Current">
            <summary>
            Gets the current thread-specific assertion scope.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.UsingLineBreaks">
            <inheritdoc cref="P:FluentAssertions.Execution.IAssertionScope.UsingLineBreaks"/>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.FormattingOptions">
            <summary>
            Exposes the options the scope will use for formatting objects in case an assertion fails.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.BecauseOf(FluentAssertions.Execution.Reason)">
            <summary>
            Adds an explanation of why the assertion is supposed to succeed to the scope.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])">
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.BecauseOf(System.String,System.Object[])"/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])">
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.WithExpectation(System.String,System.Object[])"/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.ClearExpectation">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.ForCondition(System.Boolean)">
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.ForCondition(System.Boolean)"/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.ForConstraint(FluentAssertions.OccurrenceConstraint,System.Int32)">
            <summary>
            Makes assertion fail when <paramref name="actualOccurrences"/> does not match <paramref name="constraint"/>.
            <para>
            The occurrence description in natural language could then be inserted in failure message by using
            <em>{expectedOccurrence}</em> placeholder in message parameters of <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> and its
            overloaded versions.
            </para>
            </summary>
            <param name="constraint"><see cref="T:FluentAssertions.OccurrenceConstraint"/> defining the number of expected occurrences.</param>
            <param name="actualOccurrences">The number of actual occurrences.</param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.FailWith(System.Func{FluentAssertions.Execution.FailReason})">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Func{System.Object}[])">
            <inheritdoc/>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.CallerIdentity">
            <summary>
            Gets the identity of the caller associated with the current scope.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AddPreFormattedFailure(System.String)">
            <summary>
            Adds a pre-formatted failure message to the current scope.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AppendTracing(System.String)">
            <summary>
            Adds a block of tracing to the scope for reporting when an assertion fails.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)">
            <summary>
            Tracks a keyed object in the current scope that is excluded from the failure message in case an assertion fails.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)">
            <summary>
            Adds some information to the assertion scope that will be included in the message
            that is emitted if an assertion fails.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.Func{System.String})">
            <summary>
            Adds some information to the assertion scope that will be included in the message
            that is emitted if an assertion fails. The value is only calculated on failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Discard">
            <summary>
            Returns all failures that happened up to this point and ensures they will not cause
            <see cref="M:FluentAssertions.Execution.AssertionScope.Dispose"/> to fail the assertion.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Get``1(System.String)">
            <summary>
            Gets data associated with the current scope and identified by <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.WithDefaultIdentifier(System.String)">
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.WithDefaultIdentifier(System.String)"/>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AssumeSingleCaller">
            <summary>
            Allows the scope to assume that all assertions that happen within this scope are going to
            be initiated by the same caller.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.CollectingAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContextDataItems">
            <summary>
            Represents a collection of data items that are associated with an <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Continuation">
            <summary>
            Enables chaining multiple assertions on an <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Continuation.Then">
            <summary>
            Continuous the assertion chain if the previous assertion was successful.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.Continuation.op_Implicit(FluentAssertions.Execution.Continuation)~System.Boolean">
            <summary>
            Provides back-wards compatibility for code that expects <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> to return a boolean.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContinuationOfGiven`1">
            <summary>
            Enables chaining multiple assertions from a <see cref="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})"/> call.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.ContinuationOfGiven`1.Then">
            <summary>
            Continuous the assertion chain if the previous assertion was successful.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuationOfGiven`1.op_Implicit(FluentAssertions.Execution.ContinuationOfGiven{`0})~System.Boolean">
            <summary>
            Provides back-wards compatibility for code that expects <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> to return a boolean.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContinuedAssertionScope">
            <summary>
            Allows chaining multiple assertion scopes together using <see cref="P:FluentAssertions.Execution.Continuation.Then"/>.
            </summary>
            <remarks>
            If the parent scope has captured a failed assertion,
            this class ensures that successive assertions are no longer evaluated.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.Given``1(System.Func{``0})">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.ForCondition(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.FailWith(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.FailWith(System.String,System.Func{System.Object}[])">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.FailWith(System.Func{FluentAssertions.Execution.FailReason})">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.FailWith(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.BecauseOf(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.ClearExpectation">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.WithExpectation(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.WithDefaultIdentifier(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:FluentAssertions.Execution.ContinuedAssertionScope.UsingLineBreaks">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.Discard">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuedAssertionScope.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:FluentAssertions.Execution.DefaultAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Execute">
            <summary>
            Helper class for verifying a condition and/or throwing a test harness specific exception representing an assertion failure.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Execute.Assertion">
            <summary>
            Gets an object that wraps and executes a conditional or unconditional assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.FailReason">
            <summary>
            Represents assertion fail reason. Contains the message and arguments for message's numbered placeholders.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a
            few specialized placeholders as well. For instance, <em>{reason}</em> will be replaced with the reason of the
            assertion as passed to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>.
            <para>
            Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>.
            </para>
            <para>
            Finally, a description of the current subject can be passed through the <em>{context:description}</em> placeholder.
            This is used in the message if no explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            </para>
            <para>
            Note that only 10 <c>args</c> are supported in combination with a <em>{reason}</em>.
            </para>
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.FailReason.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Execution.FailReason"/> class.
            </summary>
            <remarks>
            <inheritdoc cref="T:FluentAssertions.Execution.FailReason"/>
            </remarks>
        </member>
        <member name="P:FluentAssertions.Execution.FailReason.Message">
            <summary>
            Message to be displayed in case of failed assertion. May contain numbered
            <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders as well as specialized placeholders.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.FailReason.Args">
            <summary>
            Arguments for the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders of <see cref="P:FluentAssertions.Execution.FailReason.Message"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.FallbackTestFramework">
            <summary>
            Throws a generic exception in case no other test harness is detected.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.FallbackTestFramework.IsAvailable">
            <summary>
            Gets a value indicating whether the corresponding test framework is currently available.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.FallbackTestFramework.Throw(System.String)">
            <summary>
            Throws a framework-specific exception to indicate a failing unit test.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.GivenSelector`1">
            <summary>
            Represents a chaining object returned from <see cref="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})"/> to continue the assertion using
            an object returned by a selector.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.ForCondition(System.Func{`0,System.Boolean})">
            <summary>
            Specify the condition that must be satisfied upon the subject selected through a prior selector.
            </summary>
            <param name="predicate">
            If <c>true</c> the assertion will be treated as successful and no exceptions will be thrown.
            </param>
            <remarks>
            The condition will not be evaluated if the prior assertion failed,
            nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/> throw any exceptions.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.Given``1(System.Func{`0,``0})">
            <remarks>
            The <paramref name="selector"/> will not be invoked if the prior assertion failed,
            nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/> throw any exceptions.
            </remarks>
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.Given``1(System.Func{``0})"/>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String)">
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String)"/>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])">
            <remarks>
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String,System.Object[])"/>
            The <paramref name="args"/> will not be invoked if the prior assertion failed,
            nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/> throw any exceptions.
            </remarks>
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String,System.Object[])"/>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Object[])">
            <remarks>
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String,System.Object[])"/>
            The <paramref name="args"/> will not be invoked if the prior assertion failed,
            nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Object[])"/> throw any exceptions.
            </remarks>
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String,System.Object[])"/>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.ClearExpectation">
            <inheritdoc cref="M:FluentAssertions.Execution.IAssertionScope.ClearExpectation"/>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.Given``1(System.Func{``0})">
            <summary>
            Allows to safely select the subject for successive assertions.
            </summary>
            <paramref name="selector">
            Selector which result is passed to successive calls to <see cref="M:FluentAssertions.Execution.IAssertionScope.ForCondition(System.Boolean)"/>.
            </paramref>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.ForCondition(System.Boolean)">
            <summary>
            Specify the condition that must be satisfied.
            </summary>
            <param name="condition">
            If <c>true</c> the assertion will be treated as successful and no exceptions will be thrown.
            </param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String)">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a prior call to
            <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            Messages may contain a few specialized placeholders. For instance, <em>{reason}</em> will be replaced with the reason
            of the assertion as passed to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>.
            <para>
            Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>.
            </para>
            <para>
            Finally, a description of the current subject can be passed through the <em>{context:description}</em> placeholder.
            This is used in the message if no explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            </para>
            <para>
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure
            message is appended to that expectation.
            </para>
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.Func{FluentAssertions.Execution.FailReason})">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a prior call to
            <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            <paramref name="failReasonFunc"/> will not be called unless the assertion is not met.
            </summary>
            <param name="failReasonFunc">Function returning <see cref="T:FluentAssertions.Execution.FailReason"/> object on demand. Called only when the assertion is not met.</param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String,System.Object[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a prior call to
            <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a
            few specialized placeholders as well. For instance, <em>{reason}</em> will be replaced with the reason of the
            assertion as passed to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>.
            <para>
            Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>.
            </para>
            <para>
            Finally, a description of the current subject can be passed through the <em>{context:description}</em> placeholder.
            This is used in the message if no explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            </para>
            <para>
            Note that only 10 <paramref name="args"/> are supported in combination with a <em>{reason}</em>.
            </para>
            <para>
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure
            message is appended to that expectation.
            </para>
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.FailWith(System.String,System.Func{System.Object}[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a prior call to
            <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>,
            but postpones evaluation of the formatting arguments until the assertion really fails.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a
            few specialized placeholders as well. For instance, <em>{reason}</em> will be replaced with the reason of the
            assertion as passed to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>.
            <para>
            Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>.
            </para>
            <para>
            Finally, a description of the current subject can be passed through the <em>{context:description}</em> placeholder.
            This is used in the message if no explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            </para>
            <para>
            Note that only 10 <paramref name="argProviders"/> are supported in combination with a <em>{reason}</em>.
            </para>
            <para>
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure
            message is appended to that expectation.
            </para>
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="argProviders">Optional lazily evaluated arguments to any numbered placeholders</param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.BecauseOf(System.String,System.Object[])">
            <summary>
            Specify the reason why you expect the condition to be <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase compatible with <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the condition should
            be satisfied. If the phrase does not start with the word <em>because</em>, it is prepended to the message.
            <para>
            If the format of <paramref name="because"/> or <paramref name="becauseArgs"/> is not compatible with
            <see cref="M:System.String.Format(System.String,System.Object[])"/>, then a warning message is returned instead.
            </para>
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.ClearExpectation">
            <summary>
            Clears the expectation set by <see cref="M:FluentAssertions.Execution.IAssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.WithExpectation(System.String,System.Object[])">
            <summary>
            Sets the expectation part of the failure message when the assertion is not met.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a
            few specialized placeholders as well. For instance, <em>{reason}</em> will be replaced with the reason of the
            assertion as passed to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>.
            <para>
            Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>.
            </para>
            <para>
            Finally, a description of the current subject can be passed through the <em>{context:description}</em> placeholder.
            This is used in the message if no explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            </para>
            <para>
            Note that only 10 <paramref name="args"/> are supported in combination with a <em>{reason}</em>.
            </para>
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.WithDefaultIdentifier(System.String)">
            <summary>
            Defines the name of the subject in case this cannot be extracted from the source code.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.IAssertionScope.UsingLineBreaks">
            <summary>
            Forces the formatters, that support it, to add the necessary line breaks.
            </summary>
            <remarks>
            This is just shorthand for modifying the <see cref="P:FluentAssertions.Execution.AssertionScope.FormattingOptions"/> property.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionScope.Discard">
            <summary>
            Discards and returns the failures that happened up to now.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.IAssertionStrategy">
            <summary>
            Defines a strategy for handling failures in a <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.IAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ICloneable2">
            <summary>
            Custom version of ICloneable that works on all frameworks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ICloneable2.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Execution.ITestFramework">
            <summary>
            Represents an abstraction of a particular test framework such as MSTest, nUnit, etc.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.ITestFramework.IsAvailable">
            <summary>
            Gets a value indicating whether the corresponding test framework is currently available.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ITestFramework.Throw(System.String)">
            <summary>
            Throws a framework-specific exception to indicate a failing unit test.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.MessageBuilder">
            <summary>
            Encapsulates expanding the various placeholders supported in a failure message.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Reason">
            <summary>
            Represents the reason for a structural equivalency assertion.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Reason.FormattedMessage">
            <summary>
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Reason.Arguments">
            <summary>
            Zero or more objects to format using the placeholders in <see cref="P:FluentAssertions.Execution.Reason.FormattedMessage" />.
            </summary>
        </member>
        <member name="T:FluentAssertions.Extensions.FluentDateTimeExtensions">
            <summary>
            Extension methods on <see cref="T:System.Int32"/> to allow for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </summary>
            <example>
            Instead of<br />
            <br />
            new DateTime(2011, 3, 10)<br />
            <br />
            you can write 3.March(2011)<br />
            <br />
            Or even<br />
            <br />
            3.March(2011).At(09, 30)
            </example>
            <seealso cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.January(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month January.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.February(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month February.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.March(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month March.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.April(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month April.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.May(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month May.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.June(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month June.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.July(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month July.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.August(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month August.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.September(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month September.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.October(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month October.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.November(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month November.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.December(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month December.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.At(System.DateTime,System.TimeSpan)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="date"/> and <paramref name="time"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.At(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="date"/> and time with the specified
            <paramref name="hours"/>, <paramref name="minutes"/> and optionally <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.At(System.DateTimeOffset,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTimeOffset"/> value for the specified <paramref name="date"/> and time with the specified
            <paramref name="hours"/>, <paramref name="minutes"/> and optionally <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AsUtc(System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="dateTime"/> and time with
            the kind set to <see cref="F:System.DateTimeKind.Utc"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AsLocal(System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="dateTime"/> and time with
            the kind set to <see cref="F:System.DateTimeKind.Local"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Before(System.TimeSpan,System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value that is the current <see cref="T:System.TimeSpan"/> before the
            specified <paramref name="sourceDateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.After(System.TimeSpan,System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value that is the current <see cref="T:System.TimeSpan"/> after the
            specified <paramref name="sourceDateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Nanosecond(System.DateTime)">
            <summary>
            Gets the nanoseconds component of the date represented by the current <see cref="T:System.DateTime" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Nanosecond(System.DateTimeOffset)">
            <summary>
            Gets the nanoseconds component of the date represented by the current <see cref="T:System.DateTimeOffset" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AddNanoseconds(System.DateTime,System.Int64)">
            <summary>
            Returns a new <see cref="T:System.DateTime" /> that adds the specified number of nanoseconds to the value of this instance.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AddNanoseconds(System.DateTimeOffset,System.Int64)">
            <summary>
            Returns a new <see cref="T:System.DateTimeOffset" /> that adds the specified number of nanoseconds to the value of this instance.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Microsecond(System.DateTime)">
            <summary>
            Gets the microseconds component of the date represented by the current <see cref="T:System.DateTime" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Microsecond(System.DateTimeOffset)">
            <summary>
            Gets the microseconds component of the date represented by the current <see cref="T:System.DateTimeOffset" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AddMicroseconds(System.DateTime,System.Int64)">
            <summary>
            Returns a new <see cref="T:System.DateTime" /> that adds the specified number of microseconds to the value of this instance.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AddMicroseconds(System.DateTimeOffset,System.Int64)">
            <summary>
            Returns a new <see cref="T:System.DateTimeOffset" /> that adds the specified number of microseconds to the value of this instance.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.WithOffset(System.DateTime,System.TimeSpan)">
            <summary>
            Returns new <see cref="T:System.DateTimeOffset"/> that uses <paramref name="self"/>
            as its datetime and <paramref name="offset"/> as its offset.
            </summary>
        </member>
        <member name="T:FluentAssertions.Extensions.FluentTimeSpanExtensions">
            <summary>
            Extension methods on <see cref="T:System.Int32"/> to allow for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </summary>
            <example>
            Instead of<br />
            <br />
            TimeSpan.FromHours(12)<br />
            <br />
            you can write<br />
            <br />
            12.Hours()<br />
            <br />
            Or even<br />
            <br />
            12.Hours().And(30.Minutes()).
            </example>
            <seealso cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
        </member>
        <member name="F:FluentAssertions.Extensions.FluentTimeSpanExtensions.TicksPerMicrosecond">
            <summary>
            Represents the number of ticks that are in 1 microsecond.
            </summary>
        </member>
        <member name="F:FluentAssertions.Extensions.FluentTimeSpanExtensions.TicksPerNanosecond">
            <summary>
            Represents the number of ticks that are in 1 nanosecond.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Ticks(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of ticks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Ticks(System.Int64)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of ticks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Nanoseconds(System.TimeSpan)">
            <summary>
            Gets the nanoseconds component of the time interval represented by the current <see cref="T:System.TimeSpan" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Nanoseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of nanoseconds.
            </summary>
            <remarks>
            .NET's smallest resolutions is 100 nanoseconds. Any nanoseconds passed in
            lower than .NET's resolution will be rounded using the default rounding
            algorithm in Math.Round().
            </remarks>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Nanoseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of nanoseconds.
            </summary>
            <remarks>
            .NET's smallest resolutions is 100 nanoseconds. Any nanoseconds passed in
            lower than .NET's resolution will be rounded using the default rounding
            algorithm in Math.Round().
            </remarks>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.TotalNanoseconds(System.TimeSpan)">
            <summary>
            Gets the value of the current <see cref="T:System.TimeSpan" /> structure expressed in whole and fractional nanoseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Microseconds(System.TimeSpan)">
            <summary>
            Gets the microseconds component of the time interval represented by the current <see cref="T:System.TimeSpan" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Microseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of microseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Microseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of microseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.TotalMicroseconds(System.TimeSpan)">
            <summary>
            Gets the value of the current <see cref="T:System.TimeSpan" /> structure expressed in whole and fractional microseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Milliseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of milliseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Milliseconds(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of milliseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Seconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of seconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Seconds(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of seconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Seconds(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of seconds, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Minutes(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of minutes.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Minutes(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of minutes.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Minutes(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of minutes, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Hours(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of hours.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Hours(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of hours.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Hours(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of hours, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Days(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of days.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Days(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of days.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Days(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of days, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.And(System.TimeSpan,System.TimeSpan)">
            <summary>
            Convenience method for chaining multiple calls to the methods provided by this class.
            </summary>
            <example>
            23.Hours().And(59.Minutes())
            </example>
        </member>
        <member name="T:FluentAssertions.FluentActions">
            <summary>
            Contains static methods to help with exception assertions on actions.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentActions.Invoking(System.Action)">
            <summary>
            Invokes the specified action so that you can assert that it throws an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentActions.Invoking``1(System.Func{``0})">
            <summary>
            Invokes the specified action so that you can assert that it throws an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentActions.Awaiting(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Invokes the specified action so that you can assert that it throws an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentActions.Awaiting``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Invokes the specified action so that you can assert that it throws an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentActions.Enumerating(System.Func{System.Collections.IEnumerable})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentActions.Enumerating``1(System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.AggregateExceptionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.AttributeBasedFormatter">
            <summary>
            Specialized value formatter that looks for static methods in the caller's assembly marked with the
            <see cref="T:FluentAssertions.Formatting.ValueFormatterAttribute"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.AttributeBasedFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ByteValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DateTimeOffsetValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DecimalValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:FluentAssertions.Formatting.DefaultValueFormatter.SpacesPerIndentionLevel">
            <summary>
            The number of spaces to indent the members of this object by.
            </summary>
            <remarks>The default value is 3.</remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.CanHandle(System.Object)">
            <summary>
            Determines whether this instance can handle the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns>
            <c>true</c> if this instance can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.GetMembers(System.Type)">
            <summary>
            Selects which members of <paramref name="type"/> to format.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the object being formatted.</param>
            <returns>The members of <paramref name="type"/> that will be included when formatting this object.</returns>
            <remarks>The default is all non-private members.</remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.TypeDisplayName(System.Type)">
            <summary>
            Selects the name to display for <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the object being formatted.</param>
            <returns>The name to be displayed for <paramref name="type"/>.</returns>
            <remarks>The default is <see cref="P:System.Type.FullName"/>.</remarks>
        </member>
        <member name="P:FluentAssertions.Formatting.DictionaryValueFormatter.MaxItems">
            <summary>
            The number of items to include when formatting this object.
            </summary>
            <remarks>The default value is 32.</remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.DictionaryValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DoubleValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:FluentAssertions.Formatting.EnumerableValueFormatter.MaxItems">
            <summary>
            The number of items to include when formatting this object.
            </summary>
            <remarks>The default value is 32.</remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.EnumerableValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.EnumValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.EnumValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattedObjectGraph,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.ExceptionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExpressionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.FormatChild">
            <summary>
            Represents a method that can be used to format child values from inside an <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>.
            </summary>
            <param name="childPath">
            Represents the path from the current location to the child value.
            </param>
            <param name="value">
            The child value to format with the configured <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>s.
            </param>
        </member>
        <member name="T:FluentAssertions.Formatting.FormattedObjectGraph">
            <summary>
            This class is used by the <see cref="T:FluentAssertions.Formatting.Formatter"/> class to collect all the output of the (nested calls of an) <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> into
            a the final representation.
            </summary>
            <remarks>
            The <see cref="T:FluentAssertions.Formatting.FormattedObjectGraph"/> will ensure that the number of lines will be limited
            to the maximum number of lines provided through its constructor. It will throw
            a <see cref="T:FluentAssertions.Formatting.MaxLinesExceededException"/> if the number of lines exceeds the maximum.
            </remarks>
        </member>
        <member name="P:FluentAssertions.Formatting.FormattedObjectGraph.SpacesPerIndentation">
            <summary>
            The number of spaces that should be used by every indentation level.
            </summary>
        </member>
        <member name="P:FluentAssertions.Formatting.FormattedObjectGraph.LineCount">
            <summary>
            Returns the number of lines of text currently in the graph.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.FormattedObjectGraph.AddFragmentOnNewLine(System.String)">
            <summary>
            Starts a new line with the provided text fragment. Additional text can be added to
            that same line through <see cref="M:FluentAssertions.Formatting.FormattedObjectGraph.AddFragment(System.String)"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.FormattedObjectGraph.AddLine(System.String)">
            <summary>
            Starts a new line with the provided line of text that does not allow
            adding more fragments of text.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.FormattedObjectGraph.AddFragment(System.String)">
            <summary>
            Adds a new fragment of text to the current line.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.FormattedObjectGraph.WithIndentation">
            <summary>
            Increases the indentation of every line written into this text block until the returned disposable is disposed.
            </summary>
            <remarks>
            The amount of spacing used for each indentation level is determined by <see cref="P:FluentAssertions.Formatting.FormattedObjectGraph.SpacesPerIndentation"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.FormattedObjectGraph.ToString">
            <summary>
            Returns the final textual multi-line representation of the object graph.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.Formatter">
            <summary>
            Provides services for formatting an object being used in an assertion in a human readable format.
            </summary>
        </member>
        <member name="F:FluentAssertions.Formatting.Formatter.isReentry">
            <summary>
            Is used to detect recursive calls by <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> implementations.
            </summary>
        </member>
        <member name="P:FluentAssertions.Formatting.Formatter.Formatters">
            <summary>
            A list of objects responsible for formatting the objects represented by placeholders.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.ToString(System.Object,FluentAssertions.Formatting.FormattingOptions)">
            <summary>
            Returns a human-readable representation of a particular object.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="options">
            Indicates whether the formatter should use line breaks when the specific <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> supports it.
            </param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.RemoveFormatter(FluentAssertions.Formatting.IValueFormatter)">
            <summary>
            Removes a custom formatter that was previously added though <see cref="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)">
            <summary>
            Ensures a custom formatter is included in the chain, just before the default formatter is executed.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.Formatter.ObjectGraph">
            <summary>
            Tracks the objects that were formatted as well as the path in the object graph of
            that object.
            </summary>
            <remarks>
            Is used to detect the maximum recursion depth as well as cyclic references in the graph.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Formatting.FormattingContext">
            <summary>
            Provides information about the current formatting action.
            </summary>
        </member>
        <member name="P:FluentAssertions.Formatting.FormattingContext.UseLineBreaks">
            <summary>
            Indicates whether the formatter should use line breaks when the <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> supports it.
            </summary>
        </member>
        <member name="P:FluentAssertions.Formatting.FormattingOptions.UseLineBreaks">
            <summary>
            Indicates whether the formatter should use line breaks when the <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> supports it.
            </summary>
        </member>
        <member name="P:FluentAssertions.Formatting.FormattingOptions.MaxDepth">
            <summary>
            Determines the depth until which the library should try to render an object graph.
            </summary>
            <value>
            A depth of 1 will only the display the members of the root object.
            </value>
        </member>
        <member name="P:FluentAssertions.Formatting.FormattingOptions.MaxLines">
            <summary>
            Sets the maximum number of lines of the failure message.
            </summary>
            <remarks>
            Because of technical reasons, the actual output may be one or two lines longer.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.GuidValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Int16ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Int32ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Int64ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.IValueFormatter">
            <summary>
            Represents a strategy for formatting an arbitrary value into a human-readable string representation.
            </summary>
            <remarks>
            Add custom formatters using <see cref="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.IValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates
            whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.IValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattedObjectGraph,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <summary>
            Returns a human-readable representation of <paramref name="value"/>.
            </summary>
            <param name="value">The value to format into a human-readable representation</param>
            <param name="formattedGraph">
                An object to write the textual representation to.
            </param>
            <param name="context">
                Contains additional information that the implementation should take into account.
            </param>
            <param name="formatChild">
                Allows the formatter to recursively format any child objects.
            </param>
            <remarks>
            DO NOT CALL <see cref="M:FluentAssertions.Formatting.Formatter.ToString(System.Object,FluentAssertions.Formatting.FormattingOptions)"/> directly, but use <paramref name="formatChild"/>
            instead. This will ensure cyclic dependencies are properly detected.
            Also, the <see cref="T:FluentAssertions.Formatting.FormattedObjectGraph"/> may throw
            an <see cref="T:FluentAssertions.Formatting.MaxLinesExceededException"/> that must be ignored by implementations of this interface.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.MultidimensionalArrayFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.NullValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter">
            <summary>
            The <see cref="T:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter" /> is responsible for formatting
            boolean lambda expressions.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter.ReduceConstantSubExpressions(System.Linq.Expressions.Expression)">
            <summary>
            This step simplifies the lambda expression by replacing parts of it which do not depend on the lambda parameters
            with the actual values of these sub-expressions. The simplified expression is much easier to read.
            E.g. "(_.Text == "two") AndAlso (_.Number == 3)"
            Instead of "(_.Text == value(FluentAssertions.Specs.Collections.GenericCollectionAssertionsSpecs+c__DisplayClass122_0).twoText) AndAlso (_.Number == 3)".
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter.ExtractChainOfExpressionsJoinedWithAndOperator(System.Linq.Expressions.BinaryExpression)">
            <summary>
            This step simplifies the lambda expression by removing unnecessary parentheses for root level chain of AND operators.
            E.g. (_.Text == "two") AndAlso (_.Number == 3) AndAlso (_.OtherText == "foo")
            Instead of ((_.Text == "two") AndAlso (_.Number == 3)) AndAlso (_.OtherText == "foo")
            This simplification is only implemented for the chain of AND operators because this is the most common predicate scenario.
            Similar logic can be implemented in the future for other operators.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter.ParameterDetector">
            <summary>
            Expression visitor which can detect whether the expression depends on parameters.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter.ConstantSubExpressionReductionVisitor">
            <summary>
            Expression visitor which can replace constant sub-expressions with constant values.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter.AndOperatorChainExtractor">
            <summary>
            Expression visitor which can extract sub-expressions from an expression which has the following form:
            (SubExpression1) AND (SubExpression2) ... AND (SubExpressionN)
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.PropertyInfoFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.SByteValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.SingleValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.StringValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.TaskFormatter">
            <summary>
            Provides a human readable version of a generic or non-generic <see cref="T:System.Threading.Tasks.Task"/>
            including its state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.TimeSpanValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.UInt16ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.UInt32ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.UInt64ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.ValueFormatterAttribute">
            <summary>
            Marks a static method as a kind of <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> for a particular type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.XAttributeValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.XElementValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.XmlReaderValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FluentAssertions.NumericAssertionsExtensions">
            <summary>
            Contains a number of extension methods for floating point <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.SByte},System.SByte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Byte},System.Byte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int16},System.Int16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt16},System.UInt16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int32},System.Int32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt32},System.UInt32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int64},System.Int64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt64},System.UInt64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.SByte},System.SByte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Byte},System.Byte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int16},System.Int16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt16},System.UInt16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int32},System.Int32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt32},System.UInt32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int64},System.Int64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt64},System.UInt64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Nullable{System.Single},System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            Does not throw if null subject value approximates null <paramref name="expectedValue"/> value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Nullable{System.Double},System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            Does not throw if null subject value approximates null <paramref name="expectedValue"/> value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Nullable{System.Decimal},System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            Does not throw if null subject value approximates null <paramref name="expectedValue"/> value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Nullable{System.Single},System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value does not approximate another value by a given amount.
            Throws if both subject and <paramref name="unexpectedValue"/> are null.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Nullable{System.Double},System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value does not approximate another value by a given amount.
            Throws if both subject and <paramref name="unexpectedValue"/> are null.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Nullable{System.Decimal},System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value does not approximate another value by a given amount.
            Throws if both subject and <paramref name="unexpectedValue"/> are null.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Numeric.ComparableTypeAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable`1"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Numeric.ComparableTypeAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable`1"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object equals another object using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.<br/>
            Verification whether <see cref="M:System.IComparable`1.CompareTo(`0)"/> returns 0 is not done here, you should use
            <see cref="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeRankedEquallyTo(`0,System.String,System.Object[])"/> to verify this.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object does not equal another object using its <see cref="M:System.Object.Equals(System.Object)" /> method.<br/>
            Verification whether <see cref="M:System.IComparable`1.CompareTo(`0)"/> returns non-zero is not done here, you should use
            <see cref="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.NotBeRankedEquallyTo(`0,System.String,System.Object[])"/> to verify this.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeRankedEquallyTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is ranked equal to another object. I.e. the result of <see cref="M:System.IComparable`1.CompareTo(`0)"/> returns 0.
            To verify whether the objects are equal you must use <see cref="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.Be(`0,System.String,System.Object[])"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.NotBeRankedEquallyTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is not ranked equal to another object. I.e. the result of <see cref="M:System.IComparable`1.CompareTo(`0)"/>returns non-zero.
            To verify whether the objects are not equal according to <see cref="M:System.Object.Equals(System.Object)"/> you must use <see cref="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.NotBe(`0,System.String,System.Object[])"/>.
            </summary>
            <param name="unexpected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeLessThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is less than another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeLessThanOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is less than or equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeGreaterThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is greater than another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeGreaterThanOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is greater than or equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.BeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`2.NotBeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is not within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Numeric.ComparableTypeAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`2.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`2.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`2.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`2.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`2.Match(System.Linq.Expressions.Expression{System.Func{System.Nullable{`0},System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate" /> is satisfied.
            </summary>
            <param name="predicate">
            The predicate which must be satisfied
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Numeric.NumericAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable`1"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Numeric.NumericAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable`1"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is exactly the same as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.Be(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is exactly the same as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is not the same as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.NotBe(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is not the same as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BePositive(System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeNegative(System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeLessThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeLessThanOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than or equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeGreaterThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeGreaterThanOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than or equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.NotBeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is not within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeOneOf(`0[])">
            <summary>
            Asserts that a value is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeOneOf(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that a value is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.BeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.NotBeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is not of the specified type <paramref name="unexpectedType"/>.
            </summary>
            <param name="unexpectedType">
            The type that the subject is not supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.Match(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate" /> is satisfied.
            </summary>
            <param name="predicate">
            The predicate which must be satisfied
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeBinarySerializable(FluentAssertions.Primitives.ObjectAssertions,System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the binary serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="assertions"></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeBinarySerializable``1(FluentAssertions.Primitives.ObjectAssertions,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the binary serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="assertions"></param>
            <param name="options">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeDataContractSerializable(FluentAssertions.Primitives.ObjectAssertions,System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the data contract serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="assertions"></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeDataContractSerializable``1(FluentAssertions.Primitives.ObjectAssertions,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the data contract serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="assertions"></param>
            <param name="options">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeXmlSerializable(FluentAssertions.Primitives.ObjectAssertions,System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the XML serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="assertions"></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.BooleanAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.BooleanAssertions`1">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.BooleanAssertions`1.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions`1.BeFalse(System.String,System.Object[])">
            <summary>
            Asserts that the value is <c>false</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions`1.BeTrue(System.String,System.Object[])">
            <summary>
            Asserts that the value is <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions`1.Be(System.Boolean,System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions`1.NotBe(System.Boolean,System.String,System.Object[])">
            <summary>
            Asserts that the value is not equal to the specified <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTime"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeAssertions`1">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTime"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="P:FluentAssertions.Primitives.DateTimeAssertions`1.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.Be(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.Be(System.Nullable{System.DateTime},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBe(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> or <see cref="T:System.DateTime"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBe(System.Nullable{System.DateTime},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> or <see cref="T:System.DateTime"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeCloseTo(System.DateTime,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is within the specified time
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions`1.Be(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBeCloseTo(System.DateTime,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not within the specified time
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBe(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values must differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBeBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is not expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeOnOrBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is either on, or before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be on or before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBeOnOrBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is neither on, nor before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is not expected to be on nor before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBeAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is not expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeOnOrAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is either on, or after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be on or after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBeOnOrAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is neither on, nor after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is expected not to be on nor after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.HaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> has the <paramref name="expected"/> year.
            </summary>
            <param name="expected">The expected year of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotHaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> year.
            </summary>
            <param name="unexpected">The year that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.HaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> has the <paramref name="expected"/> month.
            </summary>
            <param name="expected">The expected month of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotHaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> month.
            </summary>
            <param name="unexpected">The month that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.HaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> day.
            </summary>
            <param name="expected">The expected day of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotHaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> day.
            </summary>
            <param name="unexpected">The day that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.HaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> hour.
            </summary>
            <param name="expected">The expected hour of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotHaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> hour.
            </summary>
            <param name="unexpected">The hour that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.HaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> minute.
            </summary>
            <param name="expected">The expected minutes of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotHaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> minute.
            </summary>
            <param name="unexpected">The minute that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.HaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> second.
            </summary>
            <param name="expected">The expected seconds of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotHaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> second.
            </summary>
            <param name="unexpected">The second that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeMoreThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should exceed compared to another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeAtLeast(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            is equal to or exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should be equal or exceed compared to
            another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeExactly(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            differs exactly the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should differ exactly compared to another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeWithin(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            is within the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should be within another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeLessThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            differs at maximum the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timeSpan">
            The maximum amount of time that the current <see cref="T:System.DateTime"/>  should differ compared to another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeSameDateAs(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> has the <paramref name="expected"/> date.
            </summary>
            <param name="expected">The expected date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.NotBeSameDateAs(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> is not the <paramref name="unexpected"/> date.
            </summary>
            <param name="unexpected">The date that is not to match the date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeOneOf(System.Nullable{System.DateTime}[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeOneOf(System.DateTime[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{System.DateTime},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{System.Nullable{System.DateTime}},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.BeIn(System.DateTimeKind,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> represents a value in the <paramref name="expectedKind"/>.
            </summary>
            <param name="expectedKind">
            The expected <see cref="T:System.DateTimeKind"/> that the current value must represent.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTimeOffset"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetAssertions`1">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTimeOffset"/>.
            </remarks>
        </member>
        <member name="P:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.Be(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> represents the same point in time as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.Be(System.Nullable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> represents the same point in time as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBe(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not represent the same point in time as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBe(System.Nullable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not represent the same point in time as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeExactly(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is exactly equal to the <paramref name="expected"/> value, including its offset.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeExactly(System.Nullable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is exactly equal to the <paramref name="expected"/> value, including its offset.
            Comparison is performed using <see cref="M:System.DateTimeOffset.EqualsExact(System.DateTimeOffset)"/>
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeExactly(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not exactly equal to the <paramref name="unexpected"/> value.
            Comparison is performed using <see cref="M:System.DateTimeOffset.EqualsExact(System.DateTimeOffset)"/>
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeExactly(System.Nullable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeCloseTo(System.DateTimeOffset,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is within the specified time
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.Be(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeCloseTo(System.DateTimeOffset,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not within the specified time
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBe(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values must differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/>  is not before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/>  that the current value is not expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeOnOrBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is either on, or before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be on or before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeOnOrBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is neither on, nor before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/> that the current value is not expected to be on nor before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/> that the current value is not expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeOnOrAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is either on, or after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be on or after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeOnOrAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/>  is neither on, nor after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/>  that the current value is expected not to be on nor after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> year.
            </summary>
            <param name="expected">The expected year of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> year.
            </summary>
            <param name="unexpected">The year that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> month.
            </summary>
            <param name="expected">The expected month of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> month.
            </summary>
            <param name="unexpected">The month that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> day.
            </summary>
            <param name="expected">The expected day of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> day.
            </summary>
            <param name="unexpected">The day that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> hour.
            </summary>
            <param name="expected">The expected hour of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> hour.
            </summary>
            <param name="unexpected">The hour that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> minute.
            </summary>
            <param name="expected">The expected minutes of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> minute.
            </summary>
            <param name="unexpected">The minute that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> second.
            </summary>
            <param name="expected">The expected seconds of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> second.
            </summary>
            <param name="unexpected">The second that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.HaveOffset(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> offset.
            </summary>
            <param name="expected">The expected offset of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotHaveOffset(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> offset.
            </summary>
            <param name="unexpected">The offset that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeMoreThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should exceed compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeAtLeast(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            is equal to or exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should be equal or exceed compared to
            another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeExactly(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            differs exactly the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should differ exactly compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeWithin(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            is within the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should be within another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeLessThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            differs at maximum the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The maximum amount of time that the current <see cref="T:System.DateTimeOffset"/> should differ compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeSameDateAs(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> date.
            </summary>
            <param name="expected">The expected date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.NotBeSameDateAs(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not the <paramref name="unexpected"/> date.
            </summary>
            <param name="unexpected">The date that is not to match the date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeOneOf(System.Nullable{System.DateTimeOffset}[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeOneOf(System.DateTimeOffset[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{System.Nullable{System.DateTimeOffset}},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1">
            <summary>
            Contains a number of methods to assert that two <see cref="T:System.DateTime"/> objects differ in the expected way.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/> and <see cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/> or a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1.Before(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTimeOffset"/> occurs a specified amount of time before another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTimeOffset"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1.After(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTimeOffset"/> occurs a specified amount of time after another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTimeOffset"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeRangeAssertions`1">
            <summary>
            Contains a number of methods to assert that two <see cref="T:System.DateTime"/> objects differ in the expected way.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/> and
            <see cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/> for a more fluent
            way of specifying a <see cref="T:System.DateTime"/> or a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions`1.Before(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTime"/> occurs a specified amount of time before another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTime"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions`1.After(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTime"/> occurs a specified amount of time after another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTime"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.EnumAssertions`1">
            <summary>
            Contains a number of methods to assert that a <typeparamref name="TEnum"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.EnumAssertions`2">
            <summary>
            Contains a number of methods to assert that a <typeparamref name="TEnum"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.Be(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> or <typeparamref name="TEnum"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.NotBe(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> or <typeparamref name="TEnum"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.HaveValue(System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.NotHaveValue(System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> is exactly equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.HaveSameValueAs``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> has the same numeric value as <paramref name="expected"/>.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.NotHaveSameValueAs``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> does not have the same numeric value as <paramref name="unexpected"/>.
            </summary>
            <param name="unexpected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.HaveSameNameAs``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> has the same name as <paramref name="expected"/>.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.NotHaveSameNameAs``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TEnum"/> does not have the same name as <paramref name="unexpected"/>.
            </summary>
            <param name="unexpected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.HaveFlag(`0,System.String,System.Object[])">
            <summary>
            Asserts that an enum has a specified flag
            </summary>
            <param name="expectedFlag">The expected flag.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.NotHaveFlag(`0,System.String,System.Object[])">
            <summary>
            Asserts that an enum does not have a specified flag
            </summary>
            <param name="unexpectedFlag">The unexpected flag.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.Match(System.Linq.Expressions.Expression{System.Func{System.Nullable{`0},System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Enum"/> matches the <paramref name="predicate" />.
            </summary>
            <param name="predicate">
            The predicate which must be satisfied by the <typeparamref name="TEnum" />.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1" /> which can be used to chain assertions.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.BeOneOf(`0[])">
            <summary>
            Asserts that the <see cref="T:System.Enum"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.BeOneOf(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Enum"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.EnumAssertions`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.GuidAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Guid"/> is in the correct state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.GuidAssertions`1">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Guid"/> is in the correct state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.GuidAssertions`1.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is <see cref="F:System.Guid.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not <see cref="F:System.Guid.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.Be(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is equal to the <paramref name="expected"/> GUID.
            </summary>
            <param name="expected">The expected <see cref="T:System.String"/> value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentException">The format of <paramref name="expected"/> is invalid.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.Be(System.Guid,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is equal to the <paramref name="expected"/> GUID.
            </summary>
            <param name="expected">The expected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.NotBe(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not equal to the <paramref name="unexpected"/> GUID.
            </summary>
            <param name="unexpected">The unexpected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentException">The format of <paramref name="unexpected"/> is invalid.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.NotBe(System.Guid,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not equal to the <paramref name="unexpected"/> GUID.
            </summary>
            <param name="unexpected">The unexpected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.HttpResponseMessageAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Net.Http.HttpResponseMessage"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.HttpResponseMessageAssertions`1">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Net.Http.HttpResponseMessage" /> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.BeSuccessful(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is successful (2xx).
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.BeRedirection(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is redirection (3xx).
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.HaveError(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is either client (4xx) or server error (5xx).
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.HaveClientError(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is client error (4xx).
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.HaveServerError(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is server error (5xx).
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.HaveStatusCode(System.Net.HttpStatusCode,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.HttpResponseMessageAssertions`1.NotHaveStatusCode(System.Net.HttpStatusCode,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Net.HttpStatusCode"/> is not equal to the specified <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableBooleanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableBooleanAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.Be(System.Nullable{System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.NotBeFalse(System.String,System.Object[])">
            <summary>
            Asserts that the value is not <c>false</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions`1.NotBeTrue(System.String,System.Object[])">
            <summary>
            Asserts that the value is not <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTime"/> or
            <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTime"/> or
            <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions`1.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions`1.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions`1.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions`1.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableEnumAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <typeparamref name="TEnum"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableEnumAssertions`2">
            <summary>
            Contains a number of methods to assert that a nullable <typeparamref name="TEnum"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableEnumAssertions`2.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <typeparamref name="TEnum"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableEnumAssertions`2.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <typeparamref name="TEnum"/> is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableEnumAssertions`2.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <typeparamref name="TEnum"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableEnumAssertions`2.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <typeparamref name="TEnum"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableGuidAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Guid"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableGuidAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Guid"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions`1.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions`1.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions`1.Be(System.Nullable{System.Guid},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1.Be(System.Nullable{System.TimeSpan},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.ObjectAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Object"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.ObjectAssertions`2">
            <summary>
            Contains a number of methods to assert that a <typeparamref name="TSubject"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions`2.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that a <typeparamref name="TSubject"/> equals another <typeparamref name="TSubject"/> using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions`2.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that a <typeparamref name="TSubject"/> does not equal another <typeparamref name="TSubject"/> using its <see cref="M:System.Object.Equals(System.Object)" /> method.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions`2.BeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions`2.BeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            </remarks>
            <param name="expectation">The expected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions`2.NotBeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that an object is not equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="unexpected">The unexpected element.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions`2.NotBeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object is not equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            </remarks>
            <param name="unexpected">The unexpected element.</param>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.ObjectAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.ReferenceTypeAssertions`2">
            <summary>
            Contains a number of methods to assert that a reference type object is in the expected state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that the current object has not been initialized yet.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that the current object has been initialized.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeSameAs(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object reference refers to the exact same object as another object reference.
            </summary>
            <param name="expected">The expected object</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeSameAs(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object reference refers to a different object than another object reference refers to.
            </summary>
            <param name="unexpected">The unexpected object</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The expected type of the object.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is of the <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is supposed to be.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectedType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is not of the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type that the subject is not supposed to be.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is not the <paramref name="unexpectedType"/>.
            </summary>
            <param name="unexpectedType">
            The type that the subject is not supposed to be.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unexpectedType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is assignable to a variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which the object should be assignable to.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndWhichConstraint`2"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is assignable to a variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which the object should be assignable to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is not assignable to a variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which the object should not be assignable to.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is not assignable to a variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which the object should not be assignable to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Match(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate" /> is satisfied.
            </summary>
            <param name="predicate">The predicate which must be satisfied by the <typeparamref name="TSubject" />.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1" /> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Match``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate" /> is satisfied.
            </summary>
            <param name="predicate">The predicate which must be satisfied by the <typeparamref name="TSubject" />.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1" /> which can be used to chain assertions.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <c>null</c>.</exception>
        </member>
        <member name="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            It should be a user-friendly name as it is included in the failure message.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BePositive(System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BeNegative(System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.Be(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is equal to the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The expected time difference</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.NotBe(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is not equal to the
            specified <paramref name="unexpected"/> time.
            </summary>
            <param name="unexpected">The unexpected time difference</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BeLessThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BeLessThanOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than or equal to the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BeGreaterThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BeGreaterThanOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than or equal to the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.BeCloseTo(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is within the specified time
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.Be(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.NotBeCloseTo(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is not within the specified time
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.NotBe(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Primitives.StringAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.String"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Primitives.StringAssertions"/> class.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.StringAssertions`1">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.String"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Primitives.StringAssertions`1"/> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.Be(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is exactly the same as another string, including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The expected string.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeOneOf(System.String[])">
            <summary>
            Asserts that the <see cref="T:System.String"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.String"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeEquivalentTo(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is exactly the same as another string, including any leading or trailing whitespace, with
            the exception of the casing.
            </summary>
            <param name="expected">
            The string that the subject is expected to be equivalent to.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBeEquivalentTo(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is not exactly the same as another string, including any leading or trailing whitespace, with
            the exception of the casing.
            </summary>
            <param name="unexpected">
            The string that the subject is not expected to be equivalent to.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBe(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is not exactly the same as the specified <paramref name="unexpected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to be equivalent to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.Match(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches the <paramref name="wildcardPattern"/>.
            </summary>
            <param name="wildcardPattern">
            The pattern to match against the subject. This parameter can contain a combination of literal text and wildcard
            (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            <paramref name="wildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="wildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="wildcardPattern"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="wildcardPattern"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotMatch(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match the <paramref name="wildcardPattern"/>.
            </summary>
            <param name="wildcardPattern">
            The pattern to match against the subject. This parameter can contain a combination literal text and wildcard of
            (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            <paramref name="wildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="wildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="wildcardPattern"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="wildcardPattern"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.MatchEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches the <paramref name="wildcardPattern"/>.
            </summary>
            <param name="wildcardPattern">
            The pattern to match against the subject. This parameter can contain a combination of literal text and wildcard
            (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            <paramref name="wildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="wildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="wildcardPattern"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="wildcardPattern"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotMatchEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match the <paramref name="wildcardPattern"/>.
            </summary>
            <param name="wildcardPattern">
            The pattern to match against the subject. This parameter can contain a combination of literal text and wildcard
            (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <remarks>
            <paramref name="wildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="wildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="wildcardPattern"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="wildcardPattern"/> is empty.</exception>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.MatchRegex(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.MatchRegex(System.Text.RegularExpressions.Regex,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotMatchRegex(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotMatchRegex(System.Text.RegularExpressions.Regex,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.StartWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string starts exactly with the specified <paramref name="expected"/> value,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The string that the subject is expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotStartWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not start with the specified <paramref name="unexpected"/> value,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.StartWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string starts with the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotStartWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not start with the specified <paramref name="unexpected"/> value,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.EndWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string ends exactly with the specified <paramref name="expected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The string that the subject is expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotEndWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not end exactly with the specified <paramref name="unexpected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.EndWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string ends with the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotEndWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not end with the specified <paramref name="unexpected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.Contain(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string contains another (fragment of a) string.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should contain.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.Contain(System.String,FluentAssertions.OccurrenceConstraint,System.String,System.Object[])">
            <summary>
            Asserts that a string contains another (fragment of a) string a set amount of times.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should contain.
            </param>
            <param name="occurrenceConstraint">
            A constraint specifying the amount of times a substring should be present within the test subject.
            It can be created by invoking static methods Once, Twice, Thrice, or Times(int)
            on the classes <see cref="T:FluentAssertions.Exactly"/>, <see cref="T:FluentAssertions.AtLeast"/>, <see cref="T:FluentAssertions.MoreThan"/>, <see cref="T:FluentAssertions.AtMost"/>, and <see cref="T:FluentAssertions.LessThan"/>.
            For example, <see cref="M:FluentAssertions.Exactly.Times(System.Int32)"/> or <see cref="M:FluentAssertions.LessThan.Twice"/>.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.ContainEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string contains the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to contain.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.ContainEquivalentOf(System.String,FluentAssertions.OccurrenceConstraint,System.String,System.Object[])">
            <summary>
            Asserts that a string contains the specified <paramref name="expected"/> a set amount of times,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should contain.
            </param>
            <param name="occurrenceConstraint">
            A constraint specifying the amount of times a substring should be present within the test subject.
            It can be created by invoking static methods Once, Twice, Thrice, or Times(int)
            on the classes <see cref="T:FluentAssertions.Exactly"/>, <see cref="T:FluentAssertions.AtLeast"/>, <see cref="T:FluentAssertions.MoreThan"/>, <see cref="T:FluentAssertions.AtMost"/>, and <see cref="T:FluentAssertions.LessThan"/>.
            For example, <see cref="M:FluentAssertions.Exactly.Times(System.Int32)"/> or <see cref="M:FluentAssertions.LessThan.Twice"/>.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.ContainAll(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string contains all values present in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should all be present in the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.ContainAll(System.String[])">
            <summary>
            Asserts that a string contains all values present in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should all be present in the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.ContainAny(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string contains at least one value present in <paramref name="values"/>,.
            </summary>
            <param name="values">
            The values that should will be tested against the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.ContainAny(System.String[])">
            <summary>
            Asserts that a string contains at least one value present in <paramref name="values"/>,.
            </summary>
            <param name="values">
            The values that should will be tested against the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotContain(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain another (fragment of a) string.
            </summary>
            <param name="unexpected">
            The (fragment of a) string that the current string should not contain.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotContainAll(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain all of the strings provided in <paramref name="values"/>. The string
            may contain some subset of the provided values.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotContainAll(System.String[])">
            <summary>
            Asserts that a string does not contain all of the strings provided in <paramref name="values"/>. The string
            may contain some subset of the provided values.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotContainAny(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain any of the strings provided in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotContainAny(System.String[])">
            <summary>
            Asserts that a string does not contain any of the strings provided in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotContainEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain the specified <paramref name="unexpected"/> string,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to contain.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is not <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.HaveLength(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that a string has the specified <paramref name="expected"/> length.
            </summary>
            <param name="expected">The expected length of the string</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is neither <c>null</c> nor <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is either <c>null</c> or <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBeNullOrWhiteSpace(System.String,System.Object[])">
            <summary>
            Asserts that a string is neither <c>null</c> nor <see cref="F:System.String.Empty"/> nor white space
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeNullOrWhiteSpace(System.String,System.Object[])">
            <summary>
            Asserts that a string is either <c>null</c> or <see cref="F:System.String.Empty"/> or white space
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeUpperCased(System.String,System.Object[])">
            <summary>
            Asserts that all characters in a string are in upper casing.
            </summary>
            <remarks>
            Be careful that numbers and special characters don't have casing, so  <see cref="M:FluentAssertions.Primitives.StringAssertions`1.BeUpperCased(System.String,System.Object[])"/>
            will always fail on a string that contains anything but alphabetic characters.
            In those cases, we recommend using <see cref="M:FluentAssertions.Primitives.StringAssertions`1.NotBeLowerCased(System.String,System.Object[])"/>.
            </remarks>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBeUpperCased(System.String,System.Object[])">
            <summary>
            Asserts that all characters in a string are not in upper casing.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.BeLowerCased(System.String,System.Object[])">
            <summary>
            Asserts that all characters in a string are in lower casing.
            </summary>
            <remarks>
            Be careful that numbers and special characters don't have casing, so <see cref="M:FluentAssertions.Primitives.StringAssertions`1.BeLowerCased(System.String,System.Object[])"/> will always fail on
            a string that contains anything but alphabetic characters.
            In those cases, we recommend using <see cref="M:FluentAssertions.Primitives.StringAssertions`1.NotBeUpperCased(System.String,System.Object[])"/>.
            </remarks>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions`1.NotBeLowerCased(System.String,System.Object[])">
            <summary>
            Asserts that all characters in a string are not in lower casing.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.StringAssertions`1.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.StringValidator">
            <summary>
            Dedicated class for comparing two strings and generating consistent error messages.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.Negate">
            <summary>
            Gets or sets a value indicating whether the subject should not match the pattern.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.IgnoreCase">
            <summary>
            Gets or sets a value indicating whether the matching process should ignore any casing difference.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.IgnoreNewLineDifferences">
            <summary>
            Ignores the difference between environment newline differences
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.TimeSpanPredicate">
            <summary>
            Provides the logic and the display text for a <see cref="T:FluentAssertions.Primitives.TimeSpanCondition"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.ActionAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Action"/> yields the expected result.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ActionAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.AsyncFunctionAssertions`2">
            <summary>
            Contains a number of methods to assert that an asynchronous method yields the expected result.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions`2.CompleteWithinAsync(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <typeparamref name="TTask"/> will complete within the specified time.
            </summary>
            <param name="timeSpan">The allowed time span for the operation.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions`2.ThrowExactlyAsync``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> throws an exception of the exact type <typeparamref name="TException"/> (and not a derived exception type).
            </summary>
            <typeparam name="TException">
            The type of the exception it should throw.
            </typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>
            Returns an object that allows asserting additional members of the thrown exception.
            </returns>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions`2.ThrowAsync``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> throws an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions`2.NotThrowAsync(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions`2.NotThrowAsync``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions`2.NotThrowAfterAsync(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> stops throwing any exception
            after a specified amount of time.
            </summary>
            <remarks>
            The <see cref="T:System.Func`1"/> is invoked. If it raises an exception,
            the invocation is repeated until it either stops raising any exceptions
            or the specified wait time is exceeded.
            </remarks>
            <param name="waitTime">
            The time after which the <see cref="T:System.Func`1"/> should have stopped throwing any exception.
            </param>
            <param name="pollInterval">
            The time between subsequent invocations of the <see cref="T:System.Func`1"/>.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if waitTime or pollInterval are negative.</exception>
        </member>
        <member name="T:FluentAssertions.Specialized.DelegateAssertions`2">
            <summary>
            Contains a number of methods to assert that a synchronous method yields the expected result.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.DelegateAssertions`2.Throw``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Delegate" /> throws an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.DelegateAssertions`2.NotThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Delegate" /> does not throw an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.DelegateAssertions`2.NotThrow(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Delegate" /> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.DelegateAssertions`2.ThrowExactly``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Delegate"/> throws an exception of the exact type <typeparamref name="TException"/> (and not a derived exception type).
            </summary>
            <typeparam name="TException">
            The type of the exception it should throw.
            </typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>
            Returns an object that allows asserting additional members of the thrown exception.
            </returns>
        </member>
        <member name="M:FluentAssertions.Specialized.DelegateAssertions`2.NotThrowAfter(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Delegate"/> stops throwing any exception
            after a specified amount of time.
            </summary>
            <remarks>
            The delegate is invoked. If it raises an exception,
            the invocation is repeated until it either stops raising any exceptions
            or the specified wait time is exceeded.
            </remarks>
            <param name="waitTime">
            The time after which the delegate should have stopped throwing any exception.
            </param>
            <param name="pollInterval">
            The time between subsequent invocations of the delegate.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if waitTime or pollInterval are negative.</exception>
        </member>
        <member name="T:FluentAssertions.Specialized.DelegateAssertionsBase`2">
            <summary>
            Contains a number of methods to assert that a method yields the expected result.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.ExceptionAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Exception" /> is in the correct state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.And">
            <summary>
            Gets the exception object of the exception thrown.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.Which">
            <summary>
            Gets the exception object of the exception thrown.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithMessage(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception has a message that matches <paramref name="expectedWildcardPattern" />.
            </summary>
            <param name="expectedWildcardPattern">
            The pattern to match against the exception message. This parameter can contain a combination of literal text and
            wildcard (* and ?) characters, but it doesn't support regular expressions.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <remarks>
            <paramref name="expectedWildcardPattern"/> can be a combination of literal and wildcard characters,
            but it doesn't support regular expressions. The following wildcard specifiers are permitted in
            <paramref name="expectedWildcardPattern"/>.
            <list type="table">
            <listheader>
            <term>Wildcard character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>* (asterisk)</term>
            <description>Zero or more characters in that position.</description>
            </item>
            <item>
            <term>? (question mark)</term>
            <description>Exactly one character in that position.</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerException``1(System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of type <typeparamref name="TInnerException" />.
            </summary>
            <typeparam name="TInnerException">The expected type of the inner exception.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerException(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of type <param name="innerException" />.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerExceptionExactly``1(System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of the exact type <typeparamref name="TInnerException" /> (and not a derived exception type).
            </summary>
            <typeparam name="TInnerException">The expected type of the inner exception.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerExceptionExactly(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the thrown exception contains an inner exception of the exact type <param name="innerException" /> (and not a derived exception type).
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the exception matches a particular condition.
            </summary>
            <param name="exceptionExpression">
            The condition that the exception must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTime.#ctor(System.Action,FluentAssertions.Common.StartTimer)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="action">The action of which the execution time must be asserted.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTime.#ctor(System.Func{System.Threading.Tasks.Task},FluentAssertions.Common.StartTimer)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="action">The action of which the execution time must be asserted.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTime.#ctor(System.Action,System.String,FluentAssertions.Common.StartTimer)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="action">The action of which the execution time must be asserted.</param>
            <param name="actionDescription">The description of the action to be asserted.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTime.#ctor(System.Func{System.Threading.Tasks.Task},System.String,FluentAssertions.Common.StartTimer)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="action">The action of which the execution time must be asserted.</param>
            <param name="actionDescription">The description of the action to be asserted.</param>
            <remarks>
            This constructor is almost exact copy of the one accepting <see cref="T:System.Action"/>.
            The original constructor shall stay in place in order to keep backward-compatibility
            and to avoid unnecessary wrapping action in <see cref="P:FluentAssertions.Specialized.ExecutionTime.Task"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="T:FluentAssertions.Specialized.ExecutionTimeAssertions">
            <summary>
            Provides methods for asserting that the execution time of an <see cref="T:System.Action"/> satisfies certain conditions.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.#ctor(FluentAssertions.Specialized.ExecutionTime)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="executionTime">The execution on which time must be asserted.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.PollUntil(System.Func{System.TimeSpan,System.Boolean},System.Boolean,System.TimeSpan)">
            <summary>
            Checks the executing action if it satisfies a condition.
            If the execution runs into an exception, then this will rethrow it.
            </summary>
            <param name="condition">Condition to check on the current elapsed time.</param>
            <param name="expectedResult">Polling stops when condition returns the expected result.</param>
            <param name="rate">The rate at which the condition is re-checked.</param>
            <return>The elapsed time. (use this, don't measure twice)</return>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeLessThanOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is less than or equal to a specified amount of time.
            </summary>
            <param name="maxDuration">
            The maximum allowed duration.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeLessThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is less than a specified amount of time.
            </summary>
            <param name="maxDuration">
            The maximum allowed duration.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeGreaterThanOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is greater than or equal to a specified amount of time.
            </summary>
            <param name="minDuration">
            The minimum allowed duration.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeGreaterThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is greater than a specified amount of time.
            </summary>
            <param name="minDuration">
            The minimum allowed duration.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeCloseTo(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is within the expected duration.
            by a specified precision.
            </summary>
            <param name="expectedDuration">
            The expected duration.
            </param>
            <param name="precision">
            The maximum amount of time which the execution time may differ from the expected duration.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Specialized.FunctionAssertions`1">
            <summary>
            Contains a number of methods to assert that a synchronous function yields the expected result.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.FunctionAssertions`1.NotThrow(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.FunctionAssertions`1.NotThrowAfter(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> stops throwing any exception
            after a specified amount of time.
            </summary>
            <remarks>
            The <see cref="T:System.Func`1"/> is invoked. If it raises an exception,
            the invocation is repeated until it either stops raising any exceptions
            or the specified wait time is exceeded.
            </remarks>
            <param name="waitTime">
            The time after which the <see cref="T:System.Func`1"/> should have stopped throwing any exception.
            </param>
            <param name="pollInterval">
            The time between subsequent invocations of the <see cref="T:System.Func`1"/>.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if waitTime or pollInterval are negative.</exception>
        </member>
        <member name="M:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1.CompleteWithinAsync(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Threading.Tasks.Task`1"/> will complete within the specified time.
            </summary>
            <param name="timeSpan">The allowed time span for the operation.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1.NotThrowAsync(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Threading.Tasks.Task`1"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1.NotThrowAfterAsync(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Threading.Tasks.Task`1"/> stops throwing any exception
            after a specified amount of time.
            </summary>
            <remarks>
            The <see cref="T:System.Threading.Tasks.Task`1"/> is invoked. If it raises an exception,
            the invocation is repeated until it either stops raising any exceptions
            or the specified wait time is exceeded.
            </remarks>
            <param name="waitTime">
            The time after which the <see cref="T:System.Threading.Tasks.Task`1"/> should have stopped throwing any exception.
            </param>
            <param name="pollInterval">
            The time between subsequent invocations of the <see cref="T:System.Threading.Tasks.Task`1"/>.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if waitTime or pollInterval are negative.</exception>
        </member>
        <member name="M:FluentAssertions.Specialized.MemberExecutionTime`1.#ctor(`0,System.Linq.Expressions.Expression{System.Action{`0}},FluentAssertions.Common.StartTimer)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.MemberExecutionTime`1"/> class.
            </summary>
            <param name="subject">The object that exposes the method or property.</param>
            <param name="action">A reference to the method or property to measure the execution time of.</param>
            <exception cref="T:System.NullReferenceException"><paramref name="subject"/> is <c>null</c>.</exception>
            <exception cref="T:System.NullReferenceException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Specialized.TaskCompletionSourceAssertions`1.CompleteWithinAsync(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Threading.Tasks.Task"/> of the current <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> will complete within the specified time.
            </summary>
            <param name="timeSpan">The allowed time span for the operation.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.TaskCompletionSourceAssertions`1.NotCompleteWithinAsync(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Threading.Tasks.Task"/> of the current <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> will not complete within the specified time.
            </summary>
            <param name="timeSpan">The time span to wait for the operation.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.TaskCompletionSourceAssertions`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Reflection.AssemblyAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Reflection.Assembly"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.#ctor(System.Reflection.Assembly)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Reflection.AssemblyAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.NotReference(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Asserts that an assembly does not reference the specified assembly.
            </summary>
            <param name="assembly">The assembly which should not be referenced.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.Reference(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Asserts that an assembly references the specified assembly.
            </summary>
            <param name="assembly">The assembly which should be referenced.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.DefineType(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the Assembly defines a type called <paramref name="namespace"/> and <paramref name="name"/>.
            </summary>
            <param name="namespace">The namespace of the class.</param>
            <param name="name">The name of the class.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="P:FluentAssertions.Reflection.AssemblyAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Streams.BufferedStreamAssertions">
             <summary>
             Contains a number of methods to assert that an <see cref="T:System.IO.Stream"/> is in the expected state.
             </summary>
            
        </member>
        <member name="T:FluentAssertions.Streams.StreamAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IO.Stream"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Streams.StreamAssertions`2">
            <summary>
            Contains a number of methods to assert that a <typeparamref name="TSubject"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is writable.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotBeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is not writable.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.BeSeekable(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is seekable.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotBeSeekable(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is not seekable.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.BeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is readable.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotBeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is not readable.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.HavePosition(System.Int64,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> has the <paramref name="expected"/> position.
            </summary>
            <param name="expected">The expected position of the current stream.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotHavePosition(System.Int64,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> does not have an <paramref name="unexpected"/> position.
            </summary>
            <param name="unexpected">The unexpected position of the current stream.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.HaveLength(System.Int64,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> has the <paramref name="expected"/> length.
            </summary>
            <param name="expected">The expected length of the current stream.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotHaveLength(System.Int64,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> does not have an <paramref name="unexpected"/> length.
            </summary>
            <param name="unexpected">The unexpected length of the current stream.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.BeReadOnly(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is read-only.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotBeReadOnly(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is not read-only.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.BeWriteOnly(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is write-only.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Streams.StreamAssertions`2.NotBeWriteOnly(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.IO.Stream"/> is not write-only.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.TypeEnumerableExtensions">
            <summary>
            Extension methods for filtering a collection of types.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreDecoratedWith``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreDecoratedWithOrInherit``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types decorated with, or inherits from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreNotDecoratedWith``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types not decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreNotDecoratedWithOrInherit``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types not decorated with and does not inherit from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreInNamespace(System.Collections.Generic.IEnumerable{System.Type},System.String)">
            <summary>
            Filters to only include types where the namespace of type is exactly <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreUnderNamespace(System.Collections.Generic.IEnumerable{System.Type},System.String)">
            <summary>
            Filters to only include types where the namespace of type is starts with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatDeriveFrom``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that subclass the specified type, but NOT the same type.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatImplement``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Determines whether a type implements an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreClasses(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that are classes.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreNotClasses(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that are not classes.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreStatic(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that are static.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreNotStatic(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that are not static.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatSatisfy(System.Collections.Generic.IEnumerable{System.Type},System.Func{System.Type,System.Boolean})">
            <summary>
            Filters to only include types that satisfies the <paramref name="predicate"/> passed.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.UnwrapTaskTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Returns T for the types which are <see cref="T:System.Threading.Tasks.Task`1" /> or <see cref="T:System.Threading.Tasks.ValueTask`1" />; the type itself otherwise
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.UnwrapEnumerableTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Returns T for the types which are <see cref="T:System.Collections.Generic.IEnumerable`1"/> or implement the <see cref="T:System.Collections.Generic.IEnumerable`1"/>; the type itself otherwise
            </summary>
        </member>
        <member name="T:FluentAssertions.TypeExtensions">
            <summary>
            Extension methods for getting method and property selectors for a type.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Reflection.Assembly)">
            <summary>
            Returns the types that are visible outside the specified <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Type)">
            <summary>
            Returns a type selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Returns a type selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Methods(System.Type)">
            <summary>
            Returns a method selector for the current <see cref="T:System.Type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Methods(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a method selector for the current <see cref="T:System.Type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="typeSelector"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Properties(System.Type)">
            <summary>
            Returns a property selector for the current <see cref="T:System.Type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Properties(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a property selector for the current <see cref="T:System.Type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="typeSelector"/> is <c>null</c>.</exception>
        </member>
        <member name="T:FluentAssertions.Types.AllTypes">
            <summary>
            Static class that allows for a 'fluent' selection of the types from an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <example>
            AllTypes.From(myAssembly)<br />
            .ThatImplement&lt;ISomeInterface&gt;<br />
            .Should()<br />
            .BeDecoratedWith&lt;SomeAttribute&gt;()
            </example>
        </member>
        <member name="M:FluentAssertions.Types.AllTypes.From(System.Reflection.Assembly)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeSelector"/> for selecting the types that are visible outside the
            specified <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The assembly from which to select the types.</param>
        </member>
        <member name="T:FluentAssertions.Types.ConstructorInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.ConstructorInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.ConstructorInfoAssertions.#ctor(System.Reflection.ConstructorInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.ConstructorInfoAssertions"/> class.
            </summary>
            <param name="constructorInfo">The constructorInfo from which to select properties.</param>
        </member>
        <member name="T:FluentAssertions.Types.MemberInfoAssertions`2">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MemberInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected member is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected member is not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected member is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="isMatchingAttributePredicate"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected member is not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="isMatchingAttributePredicate"/> is <c>null</c>.</exception>
        </member>
        <member name="T:FluentAssertions.Types.MethodBaseAssertions`2">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MethodBase"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodBaseAssertions`2.HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected member has the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessModifier"/>
            is not a <see cref="T:FluentAssertions.Common.CSharpAccessModifier"/> value.</exception>
        </member>
        <member name="M:FluentAssertions.Types.MethodBaseAssertions`2.NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected member does not have the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The unexpected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessModifier"/>
            is not a <see cref="T:FluentAssertions.Common.CSharpAccessModifier"/> value.</exception>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MethodInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.BeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is async.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotBeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is not async.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.ReturnVoid(System.String,System.Object[])">
            <summary>
            Asserts that the selected method returns void.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.Return(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected method returns <paramref name="returnType"/>.
            </summary>
            <param name="returnType">The expected return type.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="returnType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.Return``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected method returns <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The expected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotReturnVoid(System.String,System.Object[])">
            <summary>
            Asserts that the selected method does not return void.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotReturn(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected method does not return <paramref name="returnType"/>.
            </summary>
            <param name="returnType">The unexpected return type.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="returnType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotReturn``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected method does not return <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The unexpected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoSelector">
            <summary>
            Allows for fluent selection of methods of a type through reflection.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelector"/> class.
            </summary>
            <param name="type">The type from which to select methods.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelector"/> class.
            </summary>
            <param name="types">The types from which to select methods.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="types"/> is <c>null</c>.</exception>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatArePublicOrInternal">
            <summary>
            Only select the methods that are public or internal.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatReturnVoid">
            <summary>
            Only select the methods without a return value
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatDoNotReturnVoid">
            <summary>
            Only select the methods with a return value
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatReturn``1">
            <summary>
            Only select the methods that return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatDoNotReturn``1">
            <summary>
            Only select the methods that do not return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreDecoratedWith``1">
            <summary>
            Only select the methods that are decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreDecoratedWithOrInherit``1">
            <summary>
            Only select the methods that are decorated with, or inherits from a parent class, an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotDecoratedWith``1">
            <summary>
            Only select the methods that are not decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotDecoratedWithOrInherit``1">
            <summary>
            Only select the methods that are not decorated with and does not inherit from a parent class, an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreAsync">
            <summary>
            Only return methods that are async. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotAsync">
            <summary>
            Only return methods that are not async. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreStatic">
            <summary>
            Only return methods that are static. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotStatic">
            <summary>
            Only return methods that are not static. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreVirtual">
            <summary>
            Only return methods that are virtual. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotVirtual">
            <summary>
            Only return methods that are not virtual. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ReturnTypes">
            <summary>
            Select return types of the methods
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Reflection.MethodInfo"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.HasSpecialName(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method has a special name (like properties and events).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoSelectorAssertions">
            <summary>
            Contains assertions for the <see cref="T:System.Reflection.MethodInfo"/> objects returned by the parent <see cref="T:FluentAssertions.Types.MethodInfoSelector"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.#ctor(System.Reflection.MethodInfo[])">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelectorAssertions"/> class.
            </summary>
            <param name="methods">The methods to assert.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="methods"/> is <c>null</c>.</exception>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelectorAssertions.SubjectMethods">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are async.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not async.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.Be(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected methods have specified <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBe(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected methods don't have specified <paramref name="accessModifier"/>
            </summary>
            <param name="accessModifier">The expected access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelectorAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.PropertyInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected property is virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected property is not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeWritable(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a setter with the specified C# access modifier.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessModifier"/>
            is not a <see cref="T:FluentAssertions.Common.CSharpAccessModifier"/> value.</exception>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a getter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeReadable(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a getter with the specified C# access modifier.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessModifier"/>
            is not a <see cref="T:FluentAssertions.Common.CSharpAccessModifier"/> value.</exception>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not have a getter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.Return(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected property returns a specified type.
            </summary>
            <param name="propertyType">The expected type of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.Return``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected property returns <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The expected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotReturn(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not return a specified type.
            </summary>
            <param name="propertyType">The unexpected type of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotReturn``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not return <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The unexpected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoSelector">
            <summary>
            Allows for fluent selection of properties of a type through reflection.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/> class.
            </summary>
            <param name="type">The type from which to select properties.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/> class.
            </summary>
            <param name="types">The types from which to select properties.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="types"/> is <c>null</c>.</exception>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelector.ThatArePublicOrInternal">
            <summary>
            Only select the properties that have a public or internal getter.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreDecoratedWith``1">
            <summary>
            Only select the properties that are decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreDecoratedWithOrInherit``1">
            <summary>
            Only select the properties that are decorated with, or inherits from a parent class, an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreNotDecoratedWith``1">
            <summary>
            Only select the properties that are not decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreNotDecoratedWithOrInherit``1">
            <summary>
            Only select the properties that are not decorated with and does not inherit from a parent class an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.OfType``1">
            <summary>
            Only select the properties that return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.NotOfType``1">
            <summary>
            Only select the properties that do not return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ReturnTypes">
            <summary>
            Select return types of the properties
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Reflection.PropertyInfo"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoSelectorAssertions">
            <summary>
            Contains assertions for the <see cref="T:System.Reflection.PropertyInfo"/> objects returned by the parent <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelectorAssertions.SubjectProperties">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.#ctor(System.Reflection.PropertyInfo[])">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelectorAssertions"/> class, for a number of <see cref="T:System.Reflection.PropertyInfo"/> objects.
            </summary>
            <param name="properties">The properties to assert.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="properties"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.NotBeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties do not have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelectorAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Types.TypeAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Type"/> meets certain expectations.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.TypeAssertions"/> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Be``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is equal to the specified <typeparamref name="TExpected"/> type.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Be(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is equal to the specified <paramref name="expected"/> type.
            </summary>
            <param name="expected">The expected type</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is assignable variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which instances of the type should be assignable.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is assignable variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which instances of the type should be assignable.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is not assignable variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which instances of the type should not be assignable.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is not assignable variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which instances of the type should not be assignable.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.GetFailureMessageIfTypesAreDifferent(System.Type,System.Type)">
            <summary>
            Creates an error message in case the specified <paramref name="actual"/> type differs from the
            <paramref name="expected"/> type.
            </summary>
            <returns>
            An empty <see cref="T:System.String"/> if the two specified types are the same, or an error message that describes that
            the two specified types are not the same.
            </returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBe``1(System.String,System.Object[])">
            <summary>
            Asserts that the current type is not equal to the specified <typeparamref name="TUnexpected"/> type.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBe(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type is not equal to the specified <paramref name="unexpected"/> type.
            </summary>
            <param name="unexpected">The unexpected type</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with an attribute of type
            <typeparamref name="TAttribute"/> that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class,
            the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class, an
            attribute of type <typeparamref name="TAttribute"/> that matches the specified
            <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Implement(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> implements <paramref name="interfaceType"/>.
            </summary>
            <param name="interfaceType">The interface that should be implemented.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Implement``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> implements interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface that should be implemented.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotImplement(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not implement <paramref name="interfaceType"/>.
            </summary>
            <param name="interfaceType">The interface that should be not implemented.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotImplement``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not implement interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface that should not be implemented.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDerivedFrom(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is derived from <paramref name="baseType"/>.
            </summary>
            <param name="baseType">The type that should be derived from.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="baseType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDerivedFrom``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is derived from <typeparamref name="TBaseClass"/>.
            </summary>
            <typeparam name="TBaseClass">The type that should be derived from.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDerivedFrom(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not derived from <paramref name="baseType"/>.
            </summary>
            <param name="baseType">The type that should not be derived from.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="baseType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDerivedFrom``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not derived from <typeparamref name="TBaseClass"/>.
            </summary>
            <typeparam name="TBaseClass">The type that should not be derived from.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeSealed(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is sealed.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject"/>
            is not a class.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeSealed(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not sealed.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject"/>
            is not a class.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAbstract(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is abstract.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject"/>
            is not a class.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeAbstract(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not abstract.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject"/>
            is not a class.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeStatic(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is static.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject"/>
            is not a class.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeStatic(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not static.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject"/>
            is not a class.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has a property of type <paramref name="propertyType"/> named
            <paramref name="name"/>.
            </summary>
            <param name="propertyType">The type of the property.</param>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has a property of type <typeparamref name="TProperty"/> named
            <paramref name="name"/>.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveProperty(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have a property named <paramref name="name"/>.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> explicitly implements a property named
            <paramref name="name"/> from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> explicitly implements a property named
            <paramref name="name"/> from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is being explicitly implemented.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not explicitly implement a property named
            <paramref name="name"/> from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not explicitly implement a property named
            <paramref name="name"/> from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is not being explicitly implemented.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> explicitly implements a method named <paramref name="name"/>
            from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitMethod``1(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> explicitly implements a method named <paramref name="name"/>
            from interface  <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is being explicitly implemented.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not explicitly implement a method named <paramref name="name"/>
            from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitMethod``1(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not explicitly implement a method named <paramref name="name"/>
            from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is not being explicitly implemented.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveIndexer(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has an indexer of type <paramref name="indexerType"/>.
            with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="indexerType">The type of the indexer.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="indexerType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveIndexer(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have an indexer that takes parameter types
            <paramref name="parameterTypes"/>.
            </summary>
            <param name="parameterTypes">The expected indexer's parameter types.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveMethod(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has a method named <paramref name="name"/> with parameter types
            <paramref name="parameterTypes"/>.
            </summary>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveMethod(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not expose a method named <paramref name="name"/>
            with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The method parameter types.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveConstructor(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has a constructor with <paramref name="parameterTypes"/>.
            </summary>
            <param name="parameterTypes">The parameter types for the indexer.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveDefaultConstructor(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has a default constructor.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveConstructor(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have a constructor with <paramref name="parameterTypes"/>.
            </summary>
            <param name="parameterTypes">The parameter types for the indexer.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterTypes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveDefaultConstructor(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have a default constructor.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessModifier"/>
            is not a <see cref="T:FluentAssertions.Common.CSharpAccessModifier"/> value.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The unexpected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessModifier"/>
            is not a <see cref="T:FluentAssertions.Common.CSharpAccessModifier"/> value.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveImplicitConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has an implicit conversion operator that converts
            <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveImplicitConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has an implicit conversion operator that converts
            <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="targetType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveImplicitConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have an implicit conversion operator that converts
            <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveImplicitConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have an implicit conversion operator that converts
            <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="targetType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has an explicit conversion operator that converts
            <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> has an explicit conversion operator that converts
            <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="targetType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have an explicit conversion operator that converts
            <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not have an explicit conversion operator that converts
            <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceType"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="targetType"/> is <c>null</c>.</exception>
        </member>
        <member name="P:FluentAssertions.Types.TypeAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.TypeSelector">
            <summary>
            Allows for fluent filtering a list of types.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Type"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDeriveFrom``1">
            <summary>
            Determines whether a type is a subclass of another type, but NOT the same type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDoNotDeriveFrom``1">
            <summary>
            Determines whether a type is not a subclass of another type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatImplement``1">
            <summary>
            Determines whether a type implements an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDoNotImplement``1">
            <summary>
            Determines whether a type does not implement an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreDecoratedWith``1">
            <summary>
            Determines whether a type is decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreDecoratedWithOrInherit``1">
            <summary>
            Determines whether a type is decorated with, or inherits from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotDecoratedWith``1">
            <summary>
            Determines whether a type is not decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotDecoratedWithOrInherit``1">
            <summary>
            Determines whether a type is not decorated with and does not inherit from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreInNamespace(System.String)">
            <summary>
            Determines whether the namespace of type is exactly <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotInNamespace(System.String)">
            <summary>
            Determines whether the namespace of type is exactly not <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreUnderNamespace(System.String)">
            <summary>
            Determines whether the namespace of type starts with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotUnderNamespace(System.String)">
            <summary>
            Determines whether the namespace of type does not start with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreClasses">
            <summary>
            Determines whether the type is a class
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotClasses">
            <summary>
            Determines whether the type is not a class
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreStatic">
            <summary>
            Determines whether the type is static
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotStatic">
            <summary>
            Determines whether the type is not static
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatSatisfy(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows to filter the types with the <paramref name="predicate"/> passed
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.UnwrapTaskTypes">
            <summary>
            Returns T for the types which are <see cref="T:System.Threading.Tasks.Task`1"/> or <see cref="T:System.Threading.Tasks.ValueTask`1"/>; the type itself otherwise
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.UnwrapEnumerableTypes">
            <summary>
            Returns T for the types which are <see cref="T:System.Collections.Generic.IEnumerable`1"/> or implement the <see cref="T:System.Collections.Generic.IEnumerable`1"/>; the type itself otherwise
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.TypeSelectorAssertions">
            <summary>
            Contains a number of methods to assert that all <see cref="T:System.Type"/>s in a <see cref="T:FluentAssertions.Types.TypeSelector"/>
            meet certain expectations.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.#ctor(System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.TypeSelectorAssertions"/> class.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.TypeSelectorAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class, the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class,  an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeSealed(System.String,System.Object[])">
            <summary>
            Asserts that the selected types are sealed
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeSealed(System.String,System.Object[])">
            <summary>
            Asserts that the all <see cref="T:System.Type"/> are not sealed classes
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeInNamespace(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is in the specified <paramref name="namespace"/>.
            </summary>
            <param name="namespace">
            The namespace that the type must be in.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeInNamespace(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not in the specified <paramref name="namespace"/>.
            </summary>
            <param name="namespace">
            The namespace that the type must not be in.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeUnderNamespace(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the namespace of the current <see cref="T:System.Type"/> starts with the specified <paramref name="namespace"/>.
            </summary>
            <param name="namespace">
            The namespace that the namespace of the type must start with.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeUnderNamespace(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the namespace of the current <see cref="T:System.Type"/>
            does not starts with the specified <paramref name="namespace"/>.
            </summary>
            <param name="namespace">
            The namespace that the namespace of the type must not start with.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:FluentAssertions.Xml.XAttributeAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.Linq.XAttribute"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.#ctor(System.Xml.Linq.XAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XAttributeAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.Be(System.Xml.Linq.XAttribute,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> equals the <paramref name="expected"/> attribute.
            </summary>
            <param name="expected">The expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.NotBe(System.Xml.Linq.XAttribute,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> does not equal the <paramref name="unexpected"/> attribute,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.HaveValue(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> has the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Xml.XAttributeAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XDocumentAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.Linq.XDocument"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.#ctor(System.Xml.Linq.XDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XDocumentAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.Be(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> equals the <paramref name="expected"/> document,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.NotBe(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> does not equal the <paramref name="unexpected"/> document,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.BeEquivalentTo(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> is equivalent to the <paramref name="expected"/> document,
            using its <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" /> implementation.
            </summary>
            <param name="expected">The expected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.NotBeEquivalentTo(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> is not equivalent to the <paramref name="unexpected"/> document,
            using its <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveRoot(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> has a root element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name of the expected root element of the current document.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveRoot(System.Xml.Linq.XName,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> has a root element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The full name <see cref="T:System.Xml.Linq.XName"/> of the expected root element of the current document.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveElement(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="P:System.Xml.Linq.XDocument.Root"/> element of the current <see cref="T:System.Xml.Linq.XDocument"/> has a direct
            child element with the specified <paramref name="expected"/> name.
            </summary>
            <param name="expected">
            The name of the expected child element of the current document's Root <see cref="P:System.Xml.Linq.XDocument.Root"/> element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveElement(System.Xml.Linq.XName,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="P:System.Xml.Linq.XDocument.Root"/> element of the current <see cref="T:System.Xml.Linq.XDocument"/> has a direct
            child element with the specified <paramref name="expected"/> name.
            </summary>
            <param name="expected">
            The full name <see cref="T:System.Xml.Linq.XName"/> of the expected child element of the current document's Root <see cref="P:System.Xml.Linq.XDocument.Root"/> element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Xml.XDocumentAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XElementAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.Linq.XElement"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.#ctor(System.Xml.Linq.XElement)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XElementAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.Be(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> equals the
            <paramref name="expected"/> element, by using
            <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)"/>
            </summary>
            <param name="expected">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.NotBe(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> does not equal the
            <paramref name="unexpected"/> element, using
            <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />.
            </summary>
            <param name="unexpected">The unexpected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.BeEquivalentTo(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> is equivalent to the
            <paramref name="expected"/> element, using a semantic equivalency
            comparison.
            </summary>
            <param name="expected">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.NotBeEquivalentTo(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> is not equivalent to
            the <paramref name="unexpected"/> element, using a semantic
            equivalency comparison.
            </summary>
            <param name="unexpected">The unexpected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveValue(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveAttribute(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has an attribute with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectedName"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveAttribute(System.Xml.Linq.XName,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has an attribute with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name <see cref="T:System.Xml.Linq.XName"/> of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expectedName"/> is <c>null</c>.</exception>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveElement(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has a direct child element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name <see cref="T:System.Xml.Linq.XName"/> of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveElement(System.Xml.Linq.XName,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has a direct child element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name <see cref="T:System.Xml.Linq.XName"/> of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c>.</exception>
        </member>
        <member name="P:FluentAssertions.Xml.XElementAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XmlElementAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.XmlElement"/>
            is in the expected state./>
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.#ctor(System.Xml.XmlElement)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XmlElementAssertions"/> class.
            </summary>
            <param name="xmlElement"></param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveInnerText(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has the specified
            <paramref name="expected"/> inner text.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveAttribute(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has an attribute
            with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveAttributeWithNamespace(System.String,System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has an attribute
            with the specified <paramref name="expectedName"/>, <paramref name="expectedNamespace"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedNamespace">The namespace of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveElement(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has a direct child element with the specified
            <paramref name="expectedName"/> name, ignoring the namespace.
            </summary>
            <param name="expectedName">The name of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveElementWithNamespace(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has a direct child element with the specified
            <paramref name="expectedName"/> name and <paramref name="expectedNamespace" /> namespace.
            </summary>
            <param name="expectedName">The name of the expected child element</param>
            <param name="expectedNamespace">The namespace of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Xml.XmlNodeAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.XmlNode"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XmlNodeAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.XmlNode"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeAssertions`2.BeEquivalentTo(System.Xml.XmlNode,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlNode"/> is equivalent to the <paramref name="expected"/> node.
            </summary>
            <param name="expected">The expected node</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeAssertions`2.NotBeEquivalentTo(System.Xml.XmlNode,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlNode"/> is not equivalent to
            the <paramref name="unexpected"/> node.
            </summary>
            <param name="unexpected">The unexpected node</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <paramref name="because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Xml.XmlNodeAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
    </members>
</doc>
